<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lemons: lemons::serializing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lemons
   </div>
   <div id="projectbrief">Utilities and building blocks for JUCE-based apps and plugins</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelemons.html">lemons</a></li><li class="navelem"><a class="el" href="namespacelemons_1_1serializing.html">serializing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lemons::serializing Namespace Reference<div class="ingroups"><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__core.html">lemons_core</a> &raquo; <a class="el" href="group__events.html">events</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo;  &#124; <a class="el" href="group__DataSynchronizer.html">DataSynchronizer</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo;  &#124; <a class="el" href="group__SerializableData.html">SerializableData</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo;  &#124; <a class="el" href="group__Serializing.html">Serializing</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo; <a class="el" href="group__Serializing.html">Serializing</a> &raquo;  &#124; <a class="el" href="group__Specializations.html">Specializations</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo; <a class="el" href="group__Serializing.html">Serializing</a> &raquo; <a class="el" href="group__Specializations.html">Specializations</a> &raquo;  &#124; <a class="el" href="group__containers.html">containers</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo; <a class="el" href="group__Serializing.html">Serializing</a> &raquo; <a class="el" href="group__Specializations.html">Specializations</a> &raquo;  &#124; <a class="el" href="group__maps.html">maps</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo; <a class="el" href="group__Serializing.html">Serializing</a> &raquo;  &#124; <a class="el" href="group__ValueTreeToJson.html">ValueTreeToJson</a><a class="el" href="group__Common.html">Common</a> &raquo; <a class="el" href="group__lemons__serializing.html">lemons_serializing</a> &raquo;  &#124; <a class="el" href="group__toggler.html">toggler</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that defines how a <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> can resize a given container during deserialization.  <a href="structlemons_1_1serializing_1_1ContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlemons_1_1serializing_1_1DataSynchronizer.html">DataSynchronizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps two copies of an object inheriting from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> in sync.  <a href="classlemons_1_1serializing_1_1DataSynchronizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1FileContents.html">FileContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a File that, when serializing, loads and saves the file's entire contents.  <a href="structlemons_1_1serializing_1_1FileContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer.html">isContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template struct that that indicates to <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> whether a given type is a container.  <a href="structlemons_1_1serializing_1_1isContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1Array_3_01ElementType_01_4_01_4.html">isContainer&lt; juce::Array&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of juce::Array is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1Array_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1OwnedArray_3_01ElementType_01_4_01_4.html">isContainer&lt; juce::OwnedArray&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of juce::OwnedArray is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1OwnedArray_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1StringArray_01_4.html">isContainer&lt; juce::StringArray &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that juce::StringArray is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1StringArray_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1array_3_01ElementType_00_01size_01_4_01_4.html">isContainer&lt; std::array&lt; ElementType, size &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::array is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1array_3_01ElementType_00_01size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1deque_3_01ElementType_01_4_01_4.html">isContainer&lt; std::deque&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::deque is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1deque_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1forward__list_3_01ElementType_01_4_01_4.html">isContainer&lt; std::forward_list&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::forward_list is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1forward__list_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1list_3_01ElementType_01_4_01_4.html">isContainer&lt; std::list&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::list is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1list_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1vector_3_01ElementType_01_4_01_4.html">isContainer&lt; std::vector&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::vector is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1vector_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isMap.html">isMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template struct that indicates to <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> whether a given type is a map.  <a href="structlemons_1_1serializing_1_1isMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isMap_3_01juce_1_1StringPairArray_01_4.html">isMap&lt; juce::StringPairArray &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html">JuceArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::Arrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1JuceArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html">JuceOwnedArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::OwnedArrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1LambdaContainerInterface.html">LambdaContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a slightly slicker interface to <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a>, allowing you to supply a lambda function to resize your container.  <a href="structlemons_1_1serializing_1_1LambdaContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1MapInterface.html">MapInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1MapInterfaceBase.html">MapInterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlemons_1_1serializing_1_1NonrealtimeMutatable.html">NonrealtimeMutatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlemons_1_1serializing_1_1RealtimeMutatable.html">RealtimeMutatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html">StdArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing std::arrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1StdArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html">STLContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing most STL containers with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1STLContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html">StringArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::StringArrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1StringArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1StringPairArrayInterface.html">StringPairArrayInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1Toggler.html">Toggler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that manages several versions of the state of a serializable object and allows you to switch between them.  <a href="structlemons_1_1serializing_1_1Toggler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1TogglerInterface.html">TogglerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that all Togglers implement to be able to access one without knowing its template arguments.  <a href="structlemons_1_1serializing_1_1TogglerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb42fe5922320e46884fd018dda44844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">copy</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:afb42fe5922320e46884fd018dda44844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from one serializable object to another by serializing the source object to a ValueTree, then deserializing the dest object from that tree.  <a href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">More...</a><br /></td></tr>
<tr class="separator:afb42fe5922320e46884fd018dda44844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047dfa3783a67d4d6690647dd45b43b"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:aa047dfa3783a67d4d6690647dd45b43b"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">createCopy</a> (ObjectType &amp;objectToCopy)</td></tr>
<tr class="memdesc:aa047dfa3783a67d4d6690647dd45b43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a serializable object by deserializing from the state of the source object.  <a href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">More...</a><br /></td></tr>
<tr class="separator:aa047dfa3783a67d4d6690647dd45b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad0f4cabd407e51b0a9f3d57512a3be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#acad0f4cabd407e51b0a9f3d57512a3be">fromBinary</a> (const juce::MemoryBlock &amp;data, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:acad0f4cabd407e51b0a9f3d57512a3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a juce::MemoryBlock.  <a href="namespacelemons_1_1serializing.html#acad0f4cabd407e51b0a9f3d57512a3be">More...</a><br /></td></tr>
<tr class="separator:acad0f4cabd407e51b0a9f3d57512a3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">fromBinary</a> (const void *data, IntegerType dataSizeInBytes, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from some arbitrary opaque binary data.  <a href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">More...</a><br /></td></tr>
<tr class="separator:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84997a7ac9a18b678f39168ba81eafdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a84997a7ac9a18b678f39168ba81eafdc">fromBinary</a> (const void *data, size_t dataSizeInBytes, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a84997a7ac9a18b678f39168ba81eafdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from some arbitrary opaque binary data.  <a href="namespacelemons_1_1serializing.html#a84997a7ac9a18b678f39168ba81eafdc">More...</a><br /></td></tr>
<tr class="separator:a84997a7ac9a18b678f39168ba81eafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47707d97df8e371fd661c3cf03ed1490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary</a> (File file, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a47707d97df8e371fd661c3cf03ed1490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a file.  <a href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">More...</a><br /></td></tr>
<tr class="separator:a47707d97df8e371fd661c3cf03ed1490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a0004a5eeed7ab3e5e3826c74e094025e">fromBinaryCreate</a> (const juce::MemoryBlock &amp;data)</td></tr>
<tr class="memdesc:a0004a5eeed7ab3e5e3826c74e094025e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the MemoryBlock.  <a href="namespacelemons_1_1serializing.html#a0004a5eeed7ab3e5e3826c74e094025e">More...</a><br /></td></tr>
<tr class="separator:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c211f61be5553bd45adc7db3b82b159"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , typename IntegerType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a2c211f61be5553bd45adc7db3b82b159"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2c211f61be5553bd45adc7db3b82b159">fromBinaryCreate</a> (const void *data, IntegerType dataSizeInBytes)</td></tr>
<tr class="memdesc:a2c211f61be5553bd45adc7db3b82b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the opaque binary data.  <a href="namespacelemons_1_1serializing.html#a2c211f61be5553bd45adc7db3b82b159">More...</a><br /></td></tr>
<tr class="separator:a2c211f61be5553bd45adc7db3b82b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354e5c3379aab3b3d5daa98339bd2376"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a354e5c3379aab3b3d5daa98339bd2376"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a354e5c3379aab3b3d5daa98339bd2376">fromBinaryCreate</a> (const void *data, size_t dataSizeInBytes)</td></tr>
<tr class="memdesc:a354e5c3379aab3b3d5daa98339bd2376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the opaque binary data.  <a href="namespacelemons_1_1serializing.html#a354e5c3379aab3b3d5daa98339bd2376">More...</a><br /></td></tr>
<tr class="separator:a354e5c3379aab3b3d5daa98339bd2376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487acb4af683b23c36066e5d8caca34"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a2487acb4af683b23c36066e5d8caca34"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">fromBinaryCreate</a> (File file)</td></tr>
<tr class="memdesc:a2487acb4af683b23c36066e5d8caca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the file.  <a href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">More...</a><br /></td></tr>
<tr class="separator:a2487acb4af683b23c36066e5d8caca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2913994bf9e1138ac4f7b70ddaa7b632">fromJSON</a> (const File &amp;file, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a JSON file.  <a href="namespacelemons_1_1serializing.html#a2913994bf9e1138ac4f7b70ddaa7b632">More...</a><br /></td></tr>
<tr class="separator:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4200231299743257683b69fbd3303e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON</a> (const String &amp;jsonText, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:ac4200231299743257683b69fbd3303e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a JSON string.  <a href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">More...</a><br /></td></tr>
<tr class="separator:ac4200231299743257683b69fbd3303e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#adbc84bfe67d82766e8ed1db9c40b6ad2">fromJSONCreate</a> (const File &amp;file)</td></tr>
<tr class="memdesc:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the JSON file.  <a href="namespacelemons_1_1serializing.html#adbc84bfe67d82766e8ed1db9c40b6ad2">More...</a><br /></td></tr>
<tr class="separator:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353856dc5625616d6d75fb7ab7b2845b"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a353856dc5625616d6d75fb7ab7b2845b"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">fromJSONCreate</a> (const String &amp;jsonText)</td></tr>
<tr class="memdesc:a353856dc5625616d6d75fb7ab7b2845b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the JSON string.  <a href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">More...</a><br /></td></tr>
<tr class="separator:a353856dc5625616d6d75fb7ab7b2845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb10991a286ec6cedc990a98a587def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">fromTree</a> (const ValueTree &amp;tree, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data)</td></tr>
<tr class="memdesc:a7eb10991a286ec6cedc990a98a587def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a ValueTree.  <a href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">More...</a><br /></td></tr>
<tr class="separator:a7eb10991a286ec6cedc990a98a587def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449fb4b02e490125b488a21ea568d0cb"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a449fb4b02e490125b488a21ea568d0cb"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">fromTreeCreate</a> (const ValueTree &amp;tree)</td></tr>
<tr class="memdesc:a449fb4b02e490125b488a21ea568d0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the ValueTree.  <a href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">More...</a><br /></td></tr>
<tr class="separator:a449fb4b02e490125b488a21ea568d0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8eb05784908c6aa35fa8499a495350"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6b8eb05784908c6aa35fa8499a495350"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a6b8eb05784908c6aa35fa8499a495350">fromVar</a> (const juce::var &amp;var)</td></tr>
<tr class="memdesc:a6b8eb05784908c6aa35fa8499a495350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calls juce::var::toString().  <a href="namespacelemons_1_1serializing.html#a6b8eb05784908c6aa35fa8499a495350">More...</a><br /></td></tr>
<tr class="separator:a6b8eb05784908c6aa35fa8499a495350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f2f10c7b4aaf9489cc1ee43c450464"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ab1f2f10c7b4aaf9489cc1ee43c450464"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">fromVar</a> (const juce::var &amp;var)</td></tr>
<tr class="memdesc:ab1f2f10c7b4aaf9489cc1ee43c450464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>.  <a href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">More...</a><br /></td></tr>
<tr class="separator:ab1f2f10c7b4aaf9489cc1ee43c450464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6351ecfc79867a4cf7a66df393babd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a6351ecfc79867a4cf7a66df393babd61">fromXML</a> (const File &amp;xmlFile, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a6351ecfc79867a4cf7a66df393babd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML file.  <a href="namespacelemons_1_1serializing.html#a6351ecfc79867a4cf7a66df393babd61">More...</a><br /></td></tr>
<tr class="separator:a6351ecfc79867a4cf7a66df393babd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfacae1d4cf28387b0b128aa39addc51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML</a> (const juce::XmlElement &amp;xml, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:abfacae1d4cf28387b0b128aa39addc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML element.  <a href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">More...</a><br /></td></tr>
<tr class="separator:abfacae1d4cf28387b0b128aa39addc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead8fccdf0fa475eee8d5277a1c7267d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aead8fccdf0fa475eee8d5277a1c7267d">fromXML</a> (std::unique_ptr&lt; juce::XmlElement &gt; xml, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:aead8fccdf0fa475eee8d5277a1c7267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML element.  <a href="namespacelemons_1_1serializing.html#aead8fccdf0fa475eee8d5277a1c7267d">More...</a><br /></td></tr>
<tr class="separator:aead8fccdf0fa475eee8d5277a1c7267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32c3104102c45dfde9bc5cd313b5de"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:abe32c3104102c45dfde9bc5cd313b5de"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abe32c3104102c45dfde9bc5cd313b5de">fromXMLCreate</a> (const File &amp;xmlFile)</td></tr>
<tr class="memdesc:abe32c3104102c45dfde9bc5cd313b5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML file.  <a href="namespacelemons_1_1serializing.html#abe32c3104102c45dfde9bc5cd313b5de">More...</a><br /></td></tr>
<tr class="separator:abe32c3104102c45dfde9bc5cd313b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4632b6fdd6053f46aea6ca54e5601481"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a4632b6fdd6053f46aea6ca54e5601481"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">fromXMLCreate</a> (const juce::XmlElement &amp;xml)</td></tr>
<tr class="memdesc:a4632b6fdd6053f46aea6ca54e5601481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML element.  <a href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">More...</a><br /></td></tr>
<tr class="separator:a4632b6fdd6053f46aea6ca54e5601481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a48182b6e883c283d2cdf15bd1bd360ec">fromXMLCreate</a> (std::unique_ptr&lt; juce::XmlElement &gt; xml)</td></tr>
<tr class="memdesc:a48182b6e883c283d2cdf15bd1bd360ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML element.  <a href="namespacelemons_1_1serializing.html#a48182b6e883c283d2cdf15bd1bd360ec">More...</a><br /></td></tr>
<tr class="separator:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66b6522f40175fa851aba1abf80050"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a9b66b6522f40175fa851aba1abf80050"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a9b66b6522f40175fa851aba1abf80050">getInterfaceForContainer</a> (ContainerType &amp;)</td></tr>
<tr class="memdesc:a9b66b6522f40175fa851aba1abf80050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function that returns an instance of the correct <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a> for the given container.  <a href="namespacelemons_1_1serializing.html#a9b66b6522f40175fa851aba1abf80050">More...</a><br /></td></tr>
<tr class="separator:a9b66b6522f40175fa851aba1abf80050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bbf011afe858bcc4ee69bc542f44fc"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a69bbf011afe858bcc4ee69bc542f44fc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a69bbf011afe858bcc4ee69bc542f44fc">getInterfaceForContainer</a> (juce::Array&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a69bbf011afe858bcc4ee69bc542f44fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html" title="Container interface that provides support for serializing juce::Arrays with TreeReflector.">JuceArrayInterface</a> for the given juce::Array.  <a href="namespacelemons_1_1serializing.html#a69bbf011afe858bcc4ee69bc542f44fc">More...</a><br /></td></tr>
<tr class="separator:a69bbf011afe858bcc4ee69bc542f44fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e0edb3064fd1e7663232842176ec1"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:ad40e0edb3064fd1e7663232842176ec1"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ad40e0edb3064fd1e7663232842176ec1">getInterfaceForContainer</a> (juce::OwnedArray&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:ad40e0edb3064fd1e7663232842176ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html" title="Container interface that provides support for serializing juce::OwnedArrays with TreeReflector.">JuceOwnedArrayInterface</a> for the given juce::OwnedArray.  <a href="namespacelemons_1_1serializing.html#ad40e0edb3064fd1e7663232842176ec1">More...</a><br /></td></tr>
<tr class="separator:ad40e0edb3064fd1e7663232842176ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8308c069f29bbcd44bc55e2c8292cf7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a8308c069f29bbcd44bc55e2c8292cf7b">getInterfaceForContainer</a> (juce::StringArray &amp;container)</td></tr>
<tr class="memdesc:a8308c069f29bbcd44bc55e2c8292cf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html" title="Container interface that provides support for serializing juce::StringArrays with TreeReflector.">StringArrayInterface</a> for the given juce::StringArray.  <a href="namespacelemons_1_1serializing.html#a8308c069f29bbcd44bc55e2c8292cf7b">More...</a><br /></td></tr>
<tr class="separator:a8308c069f29bbcd44bc55e2c8292cf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac226f9e9cdb0043fdbccd39e4759c4e0"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , size_t size&gt; </td></tr>
<tr class="memitem:ac226f9e9cdb0043fdbccd39e4759c4e0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ac226f9e9cdb0043fdbccd39e4759c4e0">getInterfaceForContainer</a> (std::array&lt; ElementType, size &gt; &amp;container)</td></tr>
<tr class="memdesc:ac226f9e9cdb0043fdbccd39e4759c4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html" title="Container interface that provides support for serializing std::arrays with TreeReflector.">StdArrayInterface</a> for the given std::array.  <a href="namespacelemons_1_1serializing.html#ac226f9e9cdb0043fdbccd39e4759c4e0">More...</a><br /></td></tr>
<tr class="separator:ac226f9e9cdb0043fdbccd39e4759c4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61393976398ed8cbe88dbdfab57a6e59"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a61393976398ed8cbe88dbdfab57a6e59"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a61393976398ed8cbe88dbdfab57a6e59">getInterfaceForContainer</a> (std::deque&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a61393976398ed8cbe88dbdfab57a6e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::deque.  <a href="namespacelemons_1_1serializing.html#a61393976398ed8cbe88dbdfab57a6e59">More...</a><br /></td></tr>
<tr class="separator:a61393976398ed8cbe88dbdfab57a6e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad400adf4f688e438a0242ff3ba1105cb"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:ad400adf4f688e438a0242ff3ba1105cb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ad400adf4f688e438a0242ff3ba1105cb">getInterfaceForContainer</a> (std::forward_list&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:ad400adf4f688e438a0242ff3ba1105cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::forward_list.  <a href="namespacelemons_1_1serializing.html#ad400adf4f688e438a0242ff3ba1105cb">More...</a><br /></td></tr>
<tr class="separator:ad400adf4f688e438a0242ff3ba1105cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49fb76eae35eaa5899043c2484446d9"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:af49fb76eae35eaa5899043c2484446d9"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#af49fb76eae35eaa5899043c2484446d9">getInterfaceForContainer</a> (std::list&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:af49fb76eae35eaa5899043c2484446d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::list.  <a href="namespacelemons_1_1serializing.html#af49fb76eae35eaa5899043c2484446d9">More...</a><br /></td></tr>
<tr class="separator:af49fb76eae35eaa5899043c2484446d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250c9e501cd46a837b512bf5e07d4266"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a250c9e501cd46a837b512bf5e07d4266"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a250c9e501cd46a837b512bf5e07d4266">getInterfaceForContainer</a> (std::vector&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a250c9e501cd46a837b512bf5e07d4266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::vector.  <a href="namespacelemons_1_1serializing.html#a250c9e501cd46a837b512bf5e07d4266">More...</a><br /></td></tr>
<tr class="separator:a250c9e501cd46a837b512bf5e07d4266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc7b394e1615b592c383f767236f7b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aadcc7b394e1615b592c383f767236f7b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1MapInterfaceBase.html">MapInterfaceBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aadcc7b394e1615b592c383f767236f7b">getInterfaceForMap</a> (juce::StringPairArray &amp;array)</td></tr>
<tr class="separator:aadcc7b394e1615b592c383f767236f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fd2901d3d0fcf54fda8c043ee0d89f"><td class="memTemplParams" colspan="2">template&lt;typename MapType &gt; </td></tr>
<tr class="memitem:ad9fd2901d3d0fcf54fda8c043ee0d89f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1MapInterfaceBase.html">MapInterfaceBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ad9fd2901d3d0fcf54fda8c043ee0d89f">getInterfaceForMap</a> (MapType &amp;)</td></tr>
<tr class="separator:ad9fd2901d3d0fcf54fda8c043ee0d89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a8faf0f6fcf3b46ecf735100cd0ec1ab9">toBinary</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data, File file)</td></tr>
<tr class="memdesc:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of an object to a file.  <a href="namespacelemons_1_1serializing.html#a8faf0f6fcf3b46ecf735100cd0ec1ab9">More...</a><br /></td></tr>
<tr class="separator:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bc185517e15eeeaac3e5695a07993f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ac6bc185517e15eeeaac3e5695a07993f">toBinary</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data, juce::MemoryBlock &amp;dest)</td></tr>
<tr class="memdesc:ac6bc185517e15eeeaac3e5695a07993f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of an object to a juce::MemoryBlock.  <a href="namespacelemons_1_1serializing.html#ac6bc185517e15eeeaac3e5695a07993f">More...</a><br /></td></tr>
<tr class="separator:ac6bc185517e15eeeaac3e5695a07993f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56277361c7ff673091449ef6626be988"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988">toJSON</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:a56277361c7ff673091449ef6626be988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a JSON string.  <a href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988">More...</a><br /></td></tr>
<tr class="separator:a56277361c7ff673091449ef6626be988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#af9dd61f7eebbc83f0b49aeb0c9733327">toJSON</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source, const File &amp;file)</td></tr>
<tr class="memdesc:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a JSON file.  <a href="namespacelemons_1_1serializing.html#af9dd61f7eebbc83f0b49aeb0c9733327">More...</a><br /></td></tr>
<tr class="separator:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24582179ee786ad4ff22a82b3070d388"><td class="memItemLeft" align="right" valign="top">ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a24582179ee786ad4ff22a82b3070d388">toTree</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data)</td></tr>
<tr class="memdesc:a24582179ee786ad4ff22a82b3070d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a ValueTree.  <a href="namespacelemons_1_1serializing.html#a24582179ee786ad4ff22a82b3070d388">More...</a><br /></td></tr>
<tr class="separator:a24582179ee786ad4ff22a82b3070d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995e9b485ca6b3b7ce540d96ec74e6a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a995e9b485ca6b3b7ce540d96ec74e6a2"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a995e9b485ca6b3b7ce540d96ec74e6a2">toVar</a> (const AudioBuffer&lt; double &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a995e9b485ca6b3b7ce540d96ec74e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an AudioBuffer to a var.  <a href="namespacelemons_1_1serializing.html#a995e9b485ca6b3b7ce540d96ec74e6a2">More...</a><br /></td></tr>
<tr class="separator:a995e9b485ca6b3b7ce540d96ec74e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24125b298d1fb471bbbdd149093dce51"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a24125b298d1fb471bbbdd149093dce51"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a24125b298d1fb471bbbdd149093dce51">toVar</a> (const AudioBuffer&lt; float &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a24125b298d1fb471bbbdd149093dce51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an AudioBuffer to a var.  <a href="namespacelemons_1_1serializing.html#a24125b298d1fb471bbbdd149093dce51">More...</a><br /></td></tr>
<tr class="separator:a24125b298d1fb471bbbdd149093dce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3cb10822960a8de86fb356660ad327"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaa3cb10822960a8de86fb356660ad327"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aaa3cb10822960a8de86fb356660ad327">toVar</a> (const File &amp;file)</td></tr>
<tr class="memdesc:aaa3cb10822960a8de86fb356660ad327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a file as its path's String representation.  <a href="namespacelemons_1_1serializing.html#aaa3cb10822960a8de86fb356660ad327">More...</a><br /></td></tr>
<tr class="separator:aaa3cb10822960a8de86fb356660ad327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb6321a773c1b99bc51b5683f6f641b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2fb6321a773c1b99bc51b5683f6f641b"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2fb6321a773c1b99bc51b5683f6f641b">toVar</a> (const juce::BigInteger &amp;bigint)</td></tr>
<tr class="memdesc:a2fb6321a773c1b99bc51b5683f6f641b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce BigInteger.  <a href="namespacelemons_1_1serializing.html#a2fb6321a773c1b99bc51b5683f6f641b">More...</a><br /></td></tr>
<tr class="separator:a2fb6321a773c1b99bc51b5683f6f641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23c33da664ac3012fbe86e5b5f68d53"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af23c33da664ac3012fbe86e5b5f68d53"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#af23c33da664ac3012fbe86e5b5f68d53">toVar</a> (const juce::Identifier &amp;ident)</td></tr>
<tr class="memdesc:af23c33da664ac3012fbe86e5b5f68d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an Identifier.  <a href="namespacelemons_1_1serializing.html#af23c33da664ac3012fbe86e5b5f68d53">More...</a><br /></td></tr>
<tr class="separator:af23c33da664ac3012fbe86e5b5f68d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3bfc8f01116f4667d90f34c0e3d8c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adc3bfc8f01116f4667d90f34c0e3d8c4"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#adc3bfc8f01116f4667d90f34c0e3d8c4">toVar</a> (const juce::Image &amp;image)</td></tr>
<tr class="memdesc:adc3bfc8f01116f4667d90f34c0e3d8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Image object using the PNG image format.  <a href="namespacelemons_1_1serializing.html#adc3bfc8f01116f4667d90f34c0e3d8c4">More...</a><br /></td></tr>
<tr class="separator:adc3bfc8f01116f4667d90f34c0e3d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b094dd9fc9a385c80072e97fb6e20e6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4b094dd9fc9a385c80072e97fb6e20e6"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a4b094dd9fc9a385c80072e97fb6e20e6">toVar</a> (const juce::IPAddress &amp;address)</td></tr>
<tr class="memdesc:a4b094dd9fc9a385c80072e97fb6e20e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an IP address as a String.  <a href="namespacelemons_1_1serializing.html#a4b094dd9fc9a385c80072e97fb6e20e6">More...</a><br /></td></tr>
<tr class="separator:a4b094dd9fc9a385c80072e97fb6e20e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b086889965f50d7dc83930d085de325"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0b086889965f50d7dc83930d085de325"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a0b086889965f50d7dc83930d085de325">toVar</a> (const juce::MemoryBlock &amp;block)</td></tr>
<tr class="memdesc:a0b086889965f50d7dc83930d085de325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a MemoryBlock.  <a href="namespacelemons_1_1serializing.html#a0b086889965f50d7dc83930d085de325">More...</a><br /></td></tr>
<tr class="separator:a0b086889965f50d7dc83930d085de325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faac5d9f8e68faafea91e27ceccc7c5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4faac5d9f8e68faafea91e27ceccc7c5"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a4faac5d9f8e68faafea91e27ceccc7c5">toVar</a> (const juce::MidiBuffer &amp;buffer)</td></tr>
<tr class="memdesc:a4faac5d9f8e68faafea91e27ceccc7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::MidiBuffer.  <a href="namespacelemons_1_1serializing.html#a4faac5d9f8e68faafea91e27ceccc7c5">More...</a><br /></td></tr>
<tr class="separator:a4faac5d9f8e68faafea91e27ceccc7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1227990759f0b34182e43aae0680d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0ff1227990759f0b34182e43aae0680d"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a0ff1227990759f0b34182e43aae0680d">toVar</a> (const juce::Point&lt; float &gt; &amp;point)</td></tr>
<tr class="memdesc:a0ff1227990759f0b34182e43aae0680d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a float Point.  <a href="namespacelemons_1_1serializing.html#a0ff1227990759f0b34182e43aae0680d">More...</a><br /></td></tr>
<tr class="separator:a0ff1227990759f0b34182e43aae0680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aac9d86072af03ffe8bfb8f8d4605c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a15aac9d86072af03ffe8bfb8f8d4605c"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a15aac9d86072af03ffe8bfb8f8d4605c">toVar</a> (const juce::Point&lt; int &gt; &amp;point)</td></tr>
<tr class="memdesc:a15aac9d86072af03ffe8bfb8f8d4605c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an integer Point.  <a href="namespacelemons_1_1serializing.html#a15aac9d86072af03ffe8bfb8f8d4605c">More...</a><br /></td></tr>
<tr class="separator:a15aac9d86072af03ffe8bfb8f8d4605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a5d01ead6cd547224b26dbe905ba41"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a14a5d01ead6cd547224b26dbe905ba41"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a14a5d01ead6cd547224b26dbe905ba41">toVar</a> (const juce::RelativeTime &amp;time)</td></tr>
<tr class="memdesc:a14a5d01ead6cd547224b26dbe905ba41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::RelativeTime object.  <a href="namespacelemons_1_1serializing.html#a14a5d01ead6cd547224b26dbe905ba41">More...</a><br /></td></tr>
<tr class="separator:a14a5d01ead6cd547224b26dbe905ba41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6587c822504cd6cd5320fa4f752371"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1c6587c822504cd6cd5320fa4f752371"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a1c6587c822504cd6cd5320fa4f752371">toVar</a> (const juce::Time &amp;time)</td></tr>
<tr class="memdesc:a1c6587c822504cd6cd5320fa4f752371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Time object by saving it as the number of milliseconds since the computing epoch.  <a href="namespacelemons_1_1serializing.html#a1c6587c822504cd6cd5320fa4f752371">More...</a><br /></td></tr>
<tr class="separator:a1c6587c822504cd6cd5320fa4f752371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3474b867dfb3bfa6d9a6e8f8122db43f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3474b867dfb3bfa6d9a6e8f8122db43f"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a3474b867dfb3bfa6d9a6e8f8122db43f">toVar</a> (const juce::URL &amp;url)</td></tr>
<tr class="memdesc:a3474b867dfb3bfa6d9a6e8f8122db43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a URL as a String.  <a href="namespacelemons_1_1serializing.html#a3474b867dfb3bfa6d9a6e8f8122db43f">More...</a><br /></td></tr>
<tr class="separator:a3474b867dfb3bfa6d9a6e8f8122db43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c4da13a83569ebfdc1e42a9c40c21"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a589c4da13a83569ebfdc1e42a9c40c21"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a589c4da13a83569ebfdc1e42a9c40c21">toVar</a> (const juce::Uuid &amp;uuid)</td></tr>
<tr class="memdesc:a589c4da13a83569ebfdc1e42a9c40c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Uuid as a String.  <a href="namespacelemons_1_1serializing.html#a589c4da13a83569ebfdc1e42a9c40c21">More...</a><br /></td></tr>
<tr class="separator:a589c4da13a83569ebfdc1e42a9c40c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2d83a5e4631fc440c00a39a8f3dac"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a87f2d83a5e4631fc440c00a39a8f3dac"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a87f2d83a5e4631fc440c00a39a8f3dac">toVar</a> (const size_t &amp;data)</td></tr>
<tr class="memdesc:a87f2d83a5e4631fc440c00a39a8f3dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a size_t.  <a href="namespacelemons_1_1serializing.html#a87f2d83a5e4631fc440c00a39a8f3dac">More...</a><br /></td></tr>
<tr class="separator:a87f2d83a5e4631fc440c00a39a8f3dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5374fbfd620b723a9320be08047ad6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3b5374fbfd620b723a9320be08047ad6"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a3b5374fbfd620b723a9320be08047ad6">toVar</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a3b5374fbfd620b723a9320be08047ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a std::string.  <a href="namespacelemons_1_1serializing.html#a3b5374fbfd620b723a9320be08047ad6">More...</a><br /></td></tr>
<tr class="separator:a3b5374fbfd620b723a9320be08047ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee0e682cb966523ed9d443e76789a2"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae8ee0e682cb966523ed9d443e76789a2"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">toVar</a> (const Type &amp;object)</td></tr>
<tr class="memdesc:ae8ee0e682cb966523ed9d443e76789a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>.  <a href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">More...</a><br /></td></tr>
<tr class="separator:ae8ee0e682cb966523ed9d443e76789a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b47fa7f8efadd549e0838a19a6ac4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a171b47fa7f8efadd549e0838a19a6ac4">toXML</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:a171b47fa7f8efadd549e0838a19a6ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to an XML element.  <a href="namespacelemons_1_1serializing.html#a171b47fa7f8efadd549e0838a19a6ac4">More...</a><br /></td></tr>
<tr class="separator:a171b47fa7f8efadd549e0838a19a6ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe15521d50b5b08e071c2de702d7d3b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#afe15521d50b5b08e071c2de702d7d3b7">toXML</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source, const File &amp;file)</td></tr>
<tr class="memdesc:afe15521d50b5b08e071c2de702d7d3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to an XML file.  <a href="namespacelemons_1_1serializing.html#afe15521d50b5b08e071c2de702d7d3b7">More...</a><br /></td></tr>
<tr class="separator:afe15521d50b5b08e071c2de702d7d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="memItemLeft" align="right" valign="top">ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0">valueTreeFromJSON</a> (const String &amp;jsonText)</td></tr>
<tr class="memdesc:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a JSON string to a ValueTree.  <a href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0">More...</a><br /></td></tr>
<tr class="separator:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dc62981a244f674a7b47738595d0ac"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac">valueTreeToJSON</a> (const ValueTree &amp;v)</td></tr>
<tr class="memdesc:a44dc62981a244f674a7b47738595d0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ValueTree to a JSON string.  <a href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac">More...</a><br /></td></tr>
<tr class="separator:a44dc62981a244f674a7b47738595d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb42fe5922320e46884fd018dda44844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb42fe5922320e46884fd018dda44844">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from one serializable object to another by serializing the source object to a ValueTree, then deserializing the dest object from that tree. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">createCopy()</a>.</p>

</div>
</div>
<a id="aa047dfa3783a67d4d6690647dd45b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047dfa3783a67d4d6690647dd45b43b">&#9670;&nbsp;</a></span>createCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::createCopy </td>
          <td>(</td>
          <td class="paramtype">ObjectType &amp;&#160;</td>
          <td class="paramname"><em>objectToCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of a serializable object by deserializing from the state of the source object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">copy()</a>.</p>

</div>
</div>
<a id="acad0f4cabd407e51b0a9f3d57512a3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad0f4cabd407e51b0a9f3d57512a3be">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a juce::MemoryBlock. </p>

</div>
</div>
<a id="a9ffdb3b15a1380f98483a7b6bb3066bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffdb3b15a1380f98483a7b6bb3066bd">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from some arbitrary opaque binary data. </p>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a84997a7ac9a18b678f39168ba81eafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84997a7ac9a18b678f39168ba81eafdc">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from some arbitrary opaque binary data. </p>

</div>
</div>
<a id="a47707d97df8e371fd661c3cf03ed1490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47707d97df8e371fd661c3cf03ed1490">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a file. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">fromBinary()</a>, and <a class="el" href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">fromBinaryCreate()</a>.</p>

</div>
</div>
<a id="a0004a5eeed7ab3e5e3826c74e094025e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0004a5eeed7ab3e5e3826c74e094025e">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the MemoryBlock. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2c211f61be5553bd45adc7db3b82b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c211f61be5553bd45adc7db3b82b159">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , typename IntegerType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the opaque binary data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a354e5c3379aab3b3d5daa98339bd2376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354e5c3379aab3b3d5daa98339bd2376">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the opaque binary data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2487acb4af683b23c36066e5d8caca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2487acb4af683b23c36066e5d8caca34">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2913994bf9e1138ac4f7b70ddaa7b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2913994bf9e1138ac4f7b70ddaa7b632">&#9670;&nbsp;</a></span>fromJSON() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromJSON </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a JSON file. </p>

</div>
</div>
<a id="ac4200231299743257683b69fbd3303e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4200231299743257683b69fbd3303e8">&#9670;&nbsp;</a></span>fromJSON() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromJSON </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a JSON string. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">fromJSONCreate()</a>.</p>

</div>
</div>
<a id="adbc84bfe67d82766e8ed1db9c40b6ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc84bfe67d82766e8ed1db9c40b6ad2">&#9670;&nbsp;</a></span>fromJSONCreate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromJSONCreate </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the JSON file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac" title="Converts a ValueTree to a JSON string.">valueTreeToJSON()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON()</a>.</p>

</div>
</div>
<a id="a353856dc5625616d6d75fb7ab7b2845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353856dc5625616d6d75fb7ab7b2845b">&#9670;&nbsp;</a></span>fromJSONCreate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromJSONCreate </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the JSON string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0" title="Converts a JSON string to a ValueTree.">valueTreeFromJSON()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON()</a>.</p>

</div>
</div>
<a id="a7eb10991a286ec6cedc990a98a587def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb10991a286ec6cedc990a98a587def">&#9670;&nbsp;</a></span>fromTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromTree </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a ValueTree. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">fromTreeCreate()</a>, and <a class="el" href="structlemons_1_1serializing_1_1Toggler.html#af7d7fe1120dc768c0f4ad45f72a0452f">lemons::serializing::Toggler&lt; 3 &gt;::loadState()</a>.</p>

</div>
</div>
<a id="a449fb4b02e490125b488a21ea568d0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449fb4b02e490125b488a21ea568d0cb">&#9670;&nbsp;</a></span>fromTreeCreate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromTreeCreate </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the ValueTree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">fromTree()</a>.</p>

</div>
</div>
<a id="a6b8eb05784908c6aa35fa8499a495350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8eb05784908c6aa35fa8499a495350">&#9670;&nbsp;</a></span>fromVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">File lemons::serializing::fromVar </td>
          <td>(</td>
          <td class="paramtype">const juce::var &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly calls juce::var::toString(). </p>
<p>Serializes a file as its path's String representation.</p>
<p>Deserializes an AudioBuffer from a var.</p>
<p>Serializes a juce::MidiBuffer.</p>
<p>Serializes a juce::Image object using the PNG image format.</p>
<p>Serializes a juce::RelativeTime object.</p>
<p>Serializes a juce::Time object by loading it as the number of milliseconds since the computing epoch.</p>
<p>Serializes a juce::Uuid as a String.</p>
<p>Serializes a std::string.</p>
<p>Serializes an IP address as a String.</p>
<p>Serializes a URL as a String.</p>
<p>Serializes a MemoryBlock.</p>
<p>Serializes an integer Point.</p>
<p>Serializes a float Point.</p>
<p>Serializes a juce BigInteger.</p>
<p>Serializes a size_t.</p>
<p>Serializes an Identifier.</p>
<p>This works by reading the contents of a String into binary form, using Base64 encoding.</p>
<p>Internally, this converts the var to a String, then uses juce's FlacAudioFormat to decode the String back into audio samples.</p>
<p>Internally, this converts the var to a String, then uses juce's FlacAudioFormat to decode the String back into audio samples. <br  />
Since juce's FlacAudioFormat is only available for float samples, the buffer is first decoded with float samples and then converted to double samples for the final result.</p>
<p>This method may be platform-dependant. I recommend using the <a class="el" href="structlemons_1_1serializing_1_1FileContents.html" title="A wrapper around a File that, when serializing, loads and saves the file&#39;s entire contents.">FileContents</a> struct to reliably serialize files' contents instead of their paths.</p>
<p>Explicitly calls juce::var::toString().</p>
<p>This function must load the complete state of your object from a juce::var. Your object type must be default-constructable. <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is creating a default-constructed instance of your object, then setting properties or relevant data members programmatically based on parsing the encoded String returned from the var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="ab1f2f10c7b4aaf9489cc1ee43c450464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f2f10c7b4aaf9489cc1ee43c450464">&#9670;&nbsp;</a></span>fromVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type lemons::serializing::fromVar </td>
          <td>(</td>
          <td class="paramtype">const juce::var &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>. </p>
<p>Explicitly calls juce::var::toString().</p>
<p>This function must load the complete state of your object from a juce::var. Your object type must be default-constructable. <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is creating a default-constructed instance of your object, then setting properties or relevant data members programmatically based on parsing the encoded String returned from the var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="a6351ecfc79867a4cf7a66df393babd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6351ecfc79867a4cf7a66df393babd61">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>xmlFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML file. </p>

</div>
</div>
<a id="abfacae1d4cf28387b0b128aa39addc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfacae1d4cf28387b0b128aa39addc51">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">const juce::XmlElement &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML element. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">fromXMLCreate()</a>.</p>

</div>
</div>
<a id="aead8fccdf0fa475eee8d5277a1c7267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead8fccdf0fa475eee8d5277a1c7267d">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML element. </p>

</div>
</div>
<a id="abe32c3104102c45dfde9bc5cd313b5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe32c3104102c45dfde9bc5cd313b5de">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>xmlFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a4632b6fdd6053f46aea6ca54e5601481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4632b6fdd6053f46aea6ca54e5601481">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">const juce::XmlElement &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a48182b6e883c283d2cdf15bd1bd360ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48182b6e883c283d2cdf15bd1bd360ec">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , LEMONS_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a9b66b6522f40175fa851aba1abf80050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66b6522f40175fa851aba1abf80050">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function that returns an instance of the correct <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a> for the given container. </p>
<p>Implement this if you want to be able to serialize a custom container type with a single <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a> call. <br  />
<br  />
</p><div class="fragment"><div class="line">    To add support <span class="keywordflow">for</span> a custom container type to <a class="code" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883">TreeReflector::add</a>():</div>
<div class="line">    - Implement a subclass of serializing::ContainerInterface with the correct resizing logic for your cotainer;</div>
<div class="line">    - Implement a specialization ofserializing::getContainerForInterface() that returns an instance of your custom interface;</div>
<div class="line">    - Specialize the serializing::isContainer struct for your type and make the specialization inherit from std::true_type.</div>
<div class="line"> </div>
<div class="line">    In addition, your custom container type must have begin() and end() functions -- ie, it must be compatable with range-based for loops.</div>
<div class="line"> </div>
<div class="line">    The elements of your container must also be valid TreeReflector::add() calls -- ie, if they don&#39;t inherit SerializableData, you must implement <a class="code" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">toVar</a>() and <a class="code" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">fromVar</a>() for the container&#39;s element type as well.</div>
<div class="line"> </div>
<div class="line">    Here is an example implementation for a custom type:</div>
<div class="line"> </div>
<div class="line">    template&lt;typename ElementType&gt;</div>
<div class="line">    struct MyContainerType</div>
<div class="line">    {</div>
<div class="line">        ElementType* begin();</div>
<div class="line">        ElementType* end();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> setSize (<span class="keywordtype">int</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: implement container interface</span></div>
<div class="line">    <span class="comment">// This tells the TreeReflector how to resize your container</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElementType&gt;</div>
<div class="line">    <span class="keyword">struct </span>MyContainerInterface : <a class="code" href="structlemons_1_1serializing_1_1ContainerInterface.html">lemons::serializing::ContainerInterface</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> Container = MyContainerType&lt;ElementType&gt;;</div>
<div class="line"> </div>
<div class="line">        MyContainerInterface (Container&amp; c) : container (c) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">void</span> resize (<span class="keywordtype">int</span> newSize) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        container.setSize (newSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        Container&amp; container;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: implement getInterfaceForContainer()</span></div>
<div class="line">    <span class="comment">// This creates an instance of your container interface for the TreeReflector to use</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ElementType &gt;</div>
<div class="line">    std::unique_ptr&lt; ContainerInterface &gt; <a class="code" href="namespacelemons_1_1serializing.html#a9b66b6522f40175fa851aba1abf80050">getInterfaceForContainer</a> (MyContainerType&lt; ElementType &gt;&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt; MyContainerInterface&lt; ElementType &gt; &gt; (container);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: implement isContainer</span></div>
<div class="line">    <span class="comment">// This tells TreeReflector that any specialization of your container type is a kind of container</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ElementType &gt;</div>
<div class="line">    <span class="keyword">struct </span>isContainer&lt; MyContainerType&lt; ElementType &gt; &gt; : std::true_type</div>
<div class="line">    {</div>
<div class="line">    };</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>The fully specialized container type &ndash; for example, std::vector&lt;int&gt; or juce::Array&lt;float&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>, <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a>, <a class="el" href="structlemons_1_1serializing_1_1isContainer.html" title="Template struct that that indicates to TreeReflector whether a given type is a container.">isContainer</a> </dd></dl>

</div>
</div>
<a id="a69bbf011afe858bcc4ee69bc542f44fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bbf011afe858bcc4ee69bc542f44fc">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::Array&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html" title="Container interface that provides support for serializing juce::Arrays with TreeReflector.">JuceArrayInterface</a> for the given juce::Array. </p>

</div>
</div>
<a id="ad40e0edb3064fd1e7663232842176ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e0edb3064fd1e7663232842176ec1">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::OwnedArray&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html" title="Container interface that provides support for serializing juce::OwnedArrays with TreeReflector.">JuceOwnedArrayInterface</a> for the given juce::OwnedArray. </p>

</div>
</div>
<a id="a8308c069f29bbcd44bc55e2c8292cf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8308c069f29bbcd44bc55e2c8292cf7b">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::StringArray &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html" title="Container interface that provides support for serializing juce::StringArrays with TreeReflector.">StringArrayInterface</a> for the given juce::StringArray. </p>

</div>
</div>
<a id="ac226f9e9cdb0043fdbccd39e4759c4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac226f9e9cdb0043fdbccd39e4759c4e0">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; ElementType, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html" title="Container interface that provides support for serializing std::arrays with TreeReflector.">StdArrayInterface</a> for the given std::array. </p>

</div>
</div>
<a id="a61393976398ed8cbe88dbdfab57a6e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61393976398ed8cbe88dbdfab57a6e59">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::deque. </p>

</div>
</div>
<a id="ad400adf4f688e438a0242ff3ba1105cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad400adf4f688e438a0242ff3ba1105cb">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::forward_list&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::forward_list. </p>

</div>
</div>
<a id="af49fb76eae35eaa5899043c2484446d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49fb76eae35eaa5899043c2484446d9">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::list. </p>

</div>
</div>
<a id="a250c9e501cd46a837b512bf5e07d4266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250c9e501cd46a837b512bf5e07d4266">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a>&gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::vector. </p>

</div>
</div>
<a id="aadcc7b394e1615b592c383f767236f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcc7b394e1615b592c383f767236f7b">&#9670;&nbsp;</a></span>getInterfaceForMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1MapInterfaceBase.html">MapInterfaceBase</a>&gt; lemons::serializing::getInterfaceForMap </td>
          <td>(</td>
          <td class="paramtype">juce::StringPairArray &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9fd2901d3d0fcf54fda8c043ee0d89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fd2901d3d0fcf54fda8c043ee0d89f">&#9670;&nbsp;</a></span>getInterfaceForMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structlemons_1_1serializing_1_1MapInterfaceBase.html">MapInterfaceBase</a>&gt; lemons::serializing::getInterfaceForMap </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8faf0f6fcf3b46ecf735100cd0ec1ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf0f6fcf3b46ecf735100cd0ec1ab9">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of an object to a file. </p>
<p>Internally, this method calls juce::ValueTree::writeToStream(), so the data is stored as an arbitrary binary encoding of a ValueTree, not necessarily a common format like XML or JSON. <br  />
 <br  />
Use the XML- and JSON-specific functions in this namespace to explicitly use either format. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a171b47fa7f8efadd549e0838a19a6ac4" title="Serializes an object to an XML element.">toXML()</a>, <a class="el" href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988" title="Serializes an object to a JSON string.">toJSON()</a> </dd></dl>

</div>
</div>
<a id="ac6bc185517e15eeeaac3e5695a07993f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bc185517e15eeeaac3e5695a07993f">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of an object to a juce::MemoryBlock. </p>

</div>
</div>
<a id="a56277361c7ff673091449ef6626be988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56277361c7ff673091449ef6626be988">&#9670;&nbsp;</a></span>toJSON() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String lemons::serializing::toJSON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a JSON string. </p>

</div>
</div>
<a id="af9dd61f7eebbc83f0b49aeb0c9733327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dd61f7eebbc83f0b49aeb0c9733327">&#9670;&nbsp;</a></span>toJSON() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toJSON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a JSON file. </p>

</div>
</div>
<a id="a24582179ee786ad4ff22a82b3070d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24582179ee786ad4ff22a82b3070d388">&#9670;&nbsp;</a></span>toTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree lemons::serializing::toTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a ValueTree. </p>

<p class="reference">Referenced by <a class="el" href="structlemons_1_1serializing_1_1Toggler.html#a6f5aac64ca3f8b96371c4168096cf446">lemons::serializing::Toggler&lt; 3 &gt;::saveState()</a>.</p>

</div>
</div>
<a id="a995e9b485ca6b3b7ce540d96ec74e6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995e9b485ca6b3b7ce540d96ec74e6a2">&#9670;&nbsp;</a></span>toVar() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const AudioBuffer&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an AudioBuffer to a var. </p>
<p>Since juce's FlacAudioFormat is only available for float samples, this first converts the buffer to floats and then uses juce::FlacAudioFormat to write the buffer's contents to a String. </p>

</div>
</div>
<a id="a24125b298d1fb471bbbdd149093dce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24125b298d1fb471bbbdd149093dce51">&#9670;&nbsp;</a></span>toVar() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const AudioBuffer&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an AudioBuffer to a var. </p>
<p>Internally, this uses juce's FlacAudioFormat to write the buffer's contents into a String. </p>

</div>
</div>
<a id="aaa3cb10822960a8de86fb356660ad327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3cb10822960a8de86fb356660ad327">&#9670;&nbsp;</a></span>toVar() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a file as its path's String representation. </p>
<p>This method may be platform-dependant. I recommend using the <a class="el" href="structlemons_1_1serializing_1_1FileContents.html" title="A wrapper around a File that, when serializing, loads and saves the file&#39;s entire contents.">FileContents</a> struct to reliably serialize files' contents instead of their paths. </p>

</div>
</div>
<a id="a2fb6321a773c1b99bc51b5683f6f641b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb6321a773c1b99bc51b5683f6f641b">&#9670;&nbsp;</a></span>toVar() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::BigInteger &amp;&#160;</td>
          <td class="paramname"><em>bigint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce BigInteger. </p>

</div>
</div>
<a id="af23c33da664ac3012fbe86e5b5f68d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23c33da664ac3012fbe86e5b5f68d53">&#9670;&nbsp;</a></span>toVar() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Identifier &amp;&#160;</td>
          <td class="paramname"><em>ident</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an Identifier. </p>

</div>
</div>
<a id="adc3bfc8f01116f4667d90f34c0e3d8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3bfc8f01116f4667d90f34c0e3d8c4">&#9670;&nbsp;</a></span>toVar() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Image object using the PNG image format. </p>

</div>
</div>
<a id="a4b094dd9fc9a385c80072e97fb6e20e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b094dd9fc9a385c80072e97fb6e20e6">&#9670;&nbsp;</a></span>toVar() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::IPAddress &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an IP address as a String. </p>

</div>
</div>
<a id="a0b086889965f50d7dc83930d085de325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b086889965f50d7dc83930d085de325">&#9670;&nbsp;</a></span>toVar() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a MemoryBlock. </p>
<p>This works by writing the contents of the memory block to a String use Base64 encoding. </p>

</div>
</div>
<a id="a4faac5d9f8e68faafea91e27ceccc7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faac5d9f8e68faafea91e27ceccc7c5">&#9670;&nbsp;</a></span>toVar() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::MidiBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::MidiBuffer. </p>

</div>
</div>
<a id="a0ff1227990759f0b34182e43aae0680d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1227990759f0b34182e43aae0680d">&#9670;&nbsp;</a></span>toVar() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Point&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a float Point. </p>

</div>
</div>
<a id="a15aac9d86072af03ffe8bfb8f8d4605c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aac9d86072af03ffe8bfb8f8d4605c">&#9670;&nbsp;</a></span>toVar() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Point&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an integer Point. </p>

</div>
</div>
<a id="a14a5d01ead6cd547224b26dbe905ba41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a5d01ead6cd547224b26dbe905ba41">&#9670;&nbsp;</a></span>toVar() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::RelativeTime &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::RelativeTime object. </p>

</div>
</div>
<a id="a1c6587c822504cd6cd5320fa4f752371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6587c822504cd6cd5320fa4f752371">&#9670;&nbsp;</a></span>toVar() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Time object by saving it as the number of milliseconds since the computing epoch. </p>

</div>
</div>
<a id="a3474b867dfb3bfa6d9a6e8f8122db43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3474b867dfb3bfa6d9a6e8f8122db43f">&#9670;&nbsp;</a></span>toVar() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::URL &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a URL as a String. </p>

</div>
</div>
<a id="a589c4da13a83569ebfdc1e42a9c40c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c4da13a83569ebfdc1e42a9c40c21">&#9670;&nbsp;</a></span>toVar() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const juce::Uuid &amp;&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Uuid as a String. </p>

</div>
</div>
<a id="a87f2d83a5e4631fc440c00a39a8f3dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2d83a5e4631fc440c00a39a8f3dac">&#9670;&nbsp;</a></span>toVar() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a size_t. </p>

</div>
</div>
<a id="a3b5374fbfd620b723a9320be08047ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5374fbfd620b723a9320be08047ad6">&#9670;&nbsp;</a></span>toVar() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a std::string. </p>

</div>
</div>
<a id="ae8ee0e682cb966523ed9d443e76789a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ee0e682cb966523ed9d443e76789a2">&#9670;&nbsp;</a></span>toVar() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>. </p>
<p>This function must save the complete state of your object either directly to a juce::var or to a type that is implicitly convertable to juce::var (ie, float, int, juce::String, etc.). <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is encoding your object into a juce::String in some way, which can then be implicitly converted to a juce::var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="a171b47fa7f8efadd549e0838a19a6ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171b47fa7f8efadd549e0838a19a6ac4">&#9670;&nbsp;</a></span>toXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;juce::XmlElement&gt; lemons::serializing::toXML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to an XML element. </p>

</div>
</div>
<a id="afe15521d50b5b08e071c2de702d7d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe15521d50b5b08e071c2de702d7d3b7">&#9670;&nbsp;</a></span>toXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toXML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to an XML file. </p>

</div>
</div>
<a id="a3a28001c151ae9a72cee950b7b0c5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a28001c151ae9a72cee950b7b0c5fe0">&#9670;&nbsp;</a></span>valueTreeFromJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree lemons::serializing::valueTreeFromJSON </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a JSON string to a ValueTree. </p>

</div>
</div>
<a id="a44dc62981a244f674a7b47738595d0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dc62981a244f674a7b47738595d0ac">&#9670;&nbsp;</a></span>valueTreeToJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String lemons::serializing::valueTreeToJSON </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ValueTree to a JSON string. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacelemons_1_1serializing_html_ab1f2f10c7b4aaf9489cc1ee43c450464"><div class="ttname"><a href="namespacelemons_1_1serializing.html#ab1f2f10c7b4aaf9489cc1ee43c450464">lemons::serializing::fromVar</a></div><div class="ttdeci">Type fromVar(const juce::var &amp;var)</div><div class="ttdoc">Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...</div><div class="ttdef"><b>Definition:</b> VarConversion.h:97</div></div>
<div class="ttc" id="anamespacelemons_1_1serializing_html_ae8ee0e682cb966523ed9d443e76789a2"><div class="ttname"><a href="namespacelemons_1_1serializing.html#ae8ee0e682cb966523ed9d443e76789a2">lemons::serializing::toVar</a></div><div class="ttdeci">juce::var toVar(const Type &amp;object)</div><div class="ttdoc">Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...</div><div class="ttdef"><b>Definition:</b> VarConversion.h:51</div></div>
<div class="ttc" id="astructlemons_1_1SerializableData_html"><div class="ttname"><a href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div><div class="ttdoc">Base class for any C++ object that needs to be serialized to binary and back.</div><div class="ttdef"><b>Definition:</b> SerializableData.h:16</div></div>
<div class="ttc" id="anamespacelemons_1_1serializing_html_a9b66b6522f40175fa851aba1abf80050"><div class="ttname"><a href="namespacelemons_1_1serializing.html#a9b66b6522f40175fa851aba1abf80050">lemons::serializing::getInterfaceForContainer</a></div><div class="ttdeci">std::unique_ptr&lt; ContainerInterface &gt; getInterfaceForContainer(ContainerType &amp;)</div><div class="ttdoc">Template function that returns an instance of the correct ContainerInterface for the given container.</div></div>
<div class="ttc" id="astructlemons_1_1serializing_1_1ContainerInterface_html"><div class="ttname"><a href="structlemons_1_1serializing_1_1ContainerInterface.html">lemons::serializing::ContainerInterface</a></div><div class="ttdoc">Interface that defines how a TreeReflector can resize a given container during deserialization.</div><div class="ttdef"><b>Definition:</b> ContainerInterface.h:19</div></div>
<div class="ttc" id="astructlemons_1_1TreeReflector_html_aa0c4f2b619acd9a3287a1f27d4c23883"><div class="ttname"><a href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883">lemons::TreeReflector::add</a></div><div class="ttdeci">void add(const String &amp;propertyName, Type &amp;object)</div><div class="ttdoc">Binds a named ValueTree property to a data member of your object.</div><div class="ttdef"><b>Definition:</b> detail.h:18</div></div>
<div class="ttc" id="anamespacelemons_html"><div class="ttname"><a href="namespacelemons.html">lemons</a></div><div class="ttdef"><b>Definition:</b> DefaultWindow.h:9</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 1 2021 00:45:43 for Lemons by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
