<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lemons: lemons::serializing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lemons
   </div>
   <div id="projectbrief">Utilities and building blocks for JUCE-based apps and plugins</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelemons.html">lemons</a></li><li class="navelem"><a class="el" href="namespacelemons_1_1serializing.html">serializing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lemons::serializing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that defines how a <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> can resize a given container during deserialization.  <a href="structlemons_1_1serializing_1_1ContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlemons_1_1serializing_1_1DataSynchronizer.html">DataSynchronizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps two copies of an object inheriting from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> in sync.  <a href="classlemons_1_1serializing_1_1DataSynchronizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer.html">isContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template struct that that indicates to <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> whether a given type is a container.  <a href="structlemons_1_1serializing_1_1isContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1Array_3_01ElementType_01_4_01_4.html">isContainer&lt; juce::Array&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of juce::Array is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1Array_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1OwnedArray_3_01ElementType_01_4_01_4.html">isContainer&lt; juce::OwnedArray&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of juce::OwnedArray is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1OwnedArray_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1StringArray_01_4.html">isContainer&lt; juce::StringArray &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that juce::StringArray is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01juce_1_1StringArray_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1array_3_01ElementType_00_01size_01_4_01_4.html">isContainer&lt; std::array&lt; ElementType, size &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::array is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1array_3_01ElementType_00_01size_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1deque_3_01ElementType_01_4_01_4.html">isContainer&lt; std::deque&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::deque is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1deque_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1forward__list_3_01ElementType_01_4_01_4.html">isContainer&lt; std::forward_list&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::forward_list is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1forward__list_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1list_3_01ElementType_01_4_01_4.html">isContainer&lt; std::list&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::list is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1list_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1vector_3_01ElementType_01_4_01_4.html">isContainer&lt; std::vector&lt; ElementType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that any specialization of std::vector is a serializable container.  <a href="structlemons_1_1serializing_1_1isContainer_3_01std_1_1vector_3_01ElementType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1isMap.html">isMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template struct that indicates to <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> whether a given type is a map.  <a href="structlemons_1_1serializing_1_1isMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html">JuceArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::Arrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1JuceArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html">JuceOwnedArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::OwnedArrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1LambdaContainerInterface.html">LambdaContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a slightly slicker interface to <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a>, allowing you to supply a lambda function to resize your container.  <a href="structlemons_1_1serializing_1_1LambdaContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html">StdArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing std::arrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1StdArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html">STLContainerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing most STL containers with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1STLContainerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html">StringArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container interface that provides support for serializing juce::StringArrays with <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>.  <a href="structlemons_1_1serializing_1_1StringArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb42fe5922320e46884fd018dda44844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">copy</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:afb42fe5922320e46884fd018dda44844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from one serializable object to another by serializing the source object to a ValueTree, then deserializing the dest object from that tree.  <a href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">More...</a><br /></td></tr>
<tr class="separator:afb42fe5922320e46884fd018dda44844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047dfa3783a67d4d6690647dd45b43b"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:aa047dfa3783a67d4d6690647dd45b43b"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">createCopy</a> (ObjectType &amp;objectToCopy)</td></tr>
<tr class="memdesc:aa047dfa3783a67d4d6690647dd45b43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a serializable object by deserializing from the state of the source object.  <a href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">More...</a><br /></td></tr>
<tr class="separator:aa047dfa3783a67d4d6690647dd45b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad0f4cabd407e51b0a9f3d57512a3be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#acad0f4cabd407e51b0a9f3d57512a3be">fromBinary</a> (const juce::MemoryBlock &amp;data, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:acad0f4cabd407e51b0a9f3d57512a3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a juce::MemoryBlock.  <a href="namespacelemons_1_1serializing.html#acad0f4cabd407e51b0a9f3d57512a3be">More...</a><br /></td></tr>
<tr class="separator:acad0f4cabd407e51b0a9f3d57512a3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">fromBinary</a> (const void *data, IntegerType dataSizeInBytes, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from some arbitrary opaque binary data.  <a href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">More...</a><br /></td></tr>
<tr class="separator:a9ffdb3b15a1380f98483a7b6bb3066bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84997a7ac9a18b678f39168ba81eafdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a84997a7ac9a18b678f39168ba81eafdc">fromBinary</a> (const void *data, size_t dataSizeInBytes, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a84997a7ac9a18b678f39168ba81eafdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from some arbitrary opaque binary data.  <a href="namespacelemons_1_1serializing.html#a84997a7ac9a18b678f39168ba81eafdc">More...</a><br /></td></tr>
<tr class="separator:a84997a7ac9a18b678f39168ba81eafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47707d97df8e371fd661c3cf03ed1490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary</a> (File file, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a47707d97df8e371fd661c3cf03ed1490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a file.  <a href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">More...</a><br /></td></tr>
<tr class="separator:a47707d97df8e371fd661c3cf03ed1490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a0004a5eeed7ab3e5e3826c74e094025e">fromBinaryCreate</a> (const juce::MemoryBlock &amp;data)</td></tr>
<tr class="memdesc:a0004a5eeed7ab3e5e3826c74e094025e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the MemoryBlock.  <a href="namespacelemons_1_1serializing.html#a0004a5eeed7ab3e5e3826c74e094025e">More...</a><br /></td></tr>
<tr class="separator:a0004a5eeed7ab3e5e3826c74e094025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c211f61be5553bd45adc7db3b82b159"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , typename IntegerType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a2c211f61be5553bd45adc7db3b82b159"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2c211f61be5553bd45adc7db3b82b159">fromBinaryCreate</a> (const void *data, IntegerType dataSizeInBytes)</td></tr>
<tr class="memdesc:a2c211f61be5553bd45adc7db3b82b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the opaque binary data.  <a href="namespacelemons_1_1serializing.html#a2c211f61be5553bd45adc7db3b82b159">More...</a><br /></td></tr>
<tr class="separator:a2c211f61be5553bd45adc7db3b82b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354e5c3379aab3b3d5daa98339bd2376"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a354e5c3379aab3b3d5daa98339bd2376"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a354e5c3379aab3b3d5daa98339bd2376">fromBinaryCreate</a> (const void *data, size_t dataSizeInBytes)</td></tr>
<tr class="memdesc:a354e5c3379aab3b3d5daa98339bd2376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the opaque binary data.  <a href="namespacelemons_1_1serializing.html#a354e5c3379aab3b3d5daa98339bd2376">More...</a><br /></td></tr>
<tr class="separator:a354e5c3379aab3b3d5daa98339bd2376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487acb4af683b23c36066e5d8caca34"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a2487acb4af683b23c36066e5d8caca34"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">fromBinaryCreate</a> (File file)</td></tr>
<tr class="memdesc:a2487acb4af683b23c36066e5d8caca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the file.  <a href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">More...</a><br /></td></tr>
<tr class="separator:a2487acb4af683b23c36066e5d8caca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2913994bf9e1138ac4f7b70ddaa7b632">fromJSON</a> (const File &amp;file, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a JSON file.  <a href="namespacelemons_1_1serializing.html#a2913994bf9e1138ac4f7b70ddaa7b632">More...</a><br /></td></tr>
<tr class="separator:a2913994bf9e1138ac4f7b70ddaa7b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4200231299743257683b69fbd3303e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON</a> (const String &amp;jsonText, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:ac4200231299743257683b69fbd3303e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a JSON string.  <a href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">More...</a><br /></td></tr>
<tr class="separator:ac4200231299743257683b69fbd3303e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#adbc84bfe67d82766e8ed1db9c40b6ad2">fromJSONCreate</a> (const File &amp;file)</td></tr>
<tr class="memdesc:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the JSON file.  <a href="namespacelemons_1_1serializing.html#adbc84bfe67d82766e8ed1db9c40b6ad2">More...</a><br /></td></tr>
<tr class="separator:adbc84bfe67d82766e8ed1db9c40b6ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353856dc5625616d6d75fb7ab7b2845b"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a353856dc5625616d6d75fb7ab7b2845b"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">fromJSONCreate</a> (const String &amp;jsonText)</td></tr>
<tr class="memdesc:a353856dc5625616d6d75fb7ab7b2845b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the JSON string.  <a href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">More...</a><br /></td></tr>
<tr class="separator:a353856dc5625616d6d75fb7ab7b2845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb10991a286ec6cedc990a98a587def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">fromTree</a> (const ValueTree &amp;tree, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data)</td></tr>
<tr class="memdesc:a7eb10991a286ec6cedc990a98a587def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from a ValueTree.  <a href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">More...</a><br /></td></tr>
<tr class="separator:a7eb10991a286ec6cedc990a98a587def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449fb4b02e490125b488a21ea568d0cb"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a449fb4b02e490125b488a21ea568d0cb"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">fromTreeCreate</a> (const ValueTree &amp;tree)</td></tr>
<tr class="memdesc:a449fb4b02e490125b488a21ea568d0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the ValueTree.  <a href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">More...</a><br /></td></tr>
<tr class="separator:a449fb4b02e490125b488a21ea568d0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff235d9553fa3ebf08d80086b25c41e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aeff235d9553fa3ebf08d80086b25c41e"><td class="memTemplItemLeft" align="right" valign="top">juce::AudioBuffer&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aeff235d9553fa3ebf08d80086b25c41e">fromVar</a> (juce::var var)</td></tr>
<tr class="memdesc:aeff235d9553fa3ebf08d80086b25c41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an AudioBuffer from a var.  <a href="namespacelemons_1_1serializing.html#aeff235d9553fa3ebf08d80086b25c41e">More...</a><br /></td></tr>
<tr class="separator:aeff235d9553fa3ebf08d80086b25c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd30f255b2b10402a940e2260f7ede3b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abd30f255b2b10402a940e2260f7ede3b"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">fromVar</a> (juce::var var)</td></tr>
<tr class="memdesc:abd30f255b2b10402a940e2260f7ede3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>.  <a href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">More...</a><br /></td></tr>
<tr class="separator:abd30f255b2b10402a940e2260f7ede3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6351ecfc79867a4cf7a66df393babd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a6351ecfc79867a4cf7a66df393babd61">fromXML</a> (const File &amp;xmlFile, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:a6351ecfc79867a4cf7a66df393babd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML file.  <a href="namespacelemons_1_1serializing.html#a6351ecfc79867a4cf7a66df393babd61">More...</a><br /></td></tr>
<tr class="separator:a6351ecfc79867a4cf7a66df393babd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfacae1d4cf28387b0b128aa39addc51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML</a> (const juce::XmlElement &amp;xml, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:abfacae1d4cf28387b0b128aa39addc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML element.  <a href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">More...</a><br /></td></tr>
<tr class="separator:abfacae1d4cf28387b0b128aa39addc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead8fccdf0fa475eee8d5277a1c7267d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aead8fccdf0fa475eee8d5277a1c7267d">fromXML</a> (std::unique_ptr&lt; juce::XmlElement &gt; xml, <a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;dest)</td></tr>
<tr class="memdesc:aead8fccdf0fa475eee8d5277a1c7267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an object from an XML element.  <a href="namespacelemons_1_1serializing.html#aead8fccdf0fa475eee8d5277a1c7267d">More...</a><br /></td></tr>
<tr class="separator:aead8fccdf0fa475eee8d5277a1c7267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32c3104102c45dfde9bc5cd313b5de"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:abe32c3104102c45dfde9bc5cd313b5de"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abe32c3104102c45dfde9bc5cd313b5de">fromXMLCreate</a> (const File &amp;xmlFile)</td></tr>
<tr class="memdesc:abe32c3104102c45dfde9bc5cd313b5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML file.  <a href="namespacelemons_1_1serializing.html#abe32c3104102c45dfde9bc5cd313b5de">More...</a><br /></td></tr>
<tr class="separator:abe32c3104102c45dfde9bc5cd313b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4632b6fdd6053f46aea6ca54e5601481"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a4632b6fdd6053f46aea6ca54e5601481"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">fromXMLCreate</a> (const juce::XmlElement &amp;xml)</td></tr>
<tr class="memdesc:a4632b6fdd6053f46aea6ca54e5601481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML element.  <a href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">More...</a><br /></td></tr>
<tr class="separator:a4632b6fdd6053f46aea6ca54e5601481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </td></tr>
<tr class="memitem:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memTemplItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a48182b6e883c283d2cdf15bd1bd360ec">fromXMLCreate</a> (std::unique_ptr&lt; juce::XmlElement &gt; xml)</td></tr>
<tr class="memdesc:a48182b6e883c283d2cdf15bd1bd360ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object from the state saved in the XML element.  <a href="namespacelemons_1_1serializing.html#a48182b6e883c283d2cdf15bd1bd360ec">More...</a><br /></td></tr>
<tr class="separator:a48182b6e883c283d2cdf15bd1bd360ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947d1fd48af7f4413f461f6c741d5fc2"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a947d1fd48af7f4413f461f6c741d5fc2"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a947d1fd48af7f4413f461f6c741d5fc2">getInterfaceForContainer</a> (ContainerType &amp;)</td></tr>
<tr class="memdesc:a947d1fd48af7f4413f461f6c741d5fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function that returns an instance of the correct <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a> for the given container.  <a href="namespacelemons_1_1serializing.html#a947d1fd48af7f4413f461f6c741d5fc2">More...</a><br /></td></tr>
<tr class="separator:a947d1fd48af7f4413f461f6c741d5fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa9bcf94a6a18b321714a7425ff0a83"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:acaa9bcf94a6a18b321714a7425ff0a83"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#acaa9bcf94a6a18b321714a7425ff0a83">getInterfaceForContainer</a> (juce::Array&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:acaa9bcf94a6a18b321714a7425ff0a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html" title="Container interface that provides support for serializing juce::Arrays with TreeReflector.">JuceArrayInterface</a> for the given juce::Array.  <a href="namespacelemons_1_1serializing.html#acaa9bcf94a6a18b321714a7425ff0a83">More...</a><br /></td></tr>
<tr class="separator:acaa9bcf94a6a18b321714a7425ff0a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bdd53db8c515549f20b1f0835052b7"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a62bdd53db8c515549f20b1f0835052b7"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a62bdd53db8c515549f20b1f0835052b7">getInterfaceForContainer</a> (juce::OwnedArray&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a62bdd53db8c515549f20b1f0835052b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html" title="Container interface that provides support for serializing juce::OwnedArrays with TreeReflector.">JuceOwnedArrayInterface</a> for the given juce::OwnedArray.  <a href="namespacelemons_1_1serializing.html#a62bdd53db8c515549f20b1f0835052b7">More...</a><br /></td></tr>
<tr class="separator:a62bdd53db8c515549f20b1f0835052b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451726fdfd9955d7017ac2b529f44eb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a5451726fdfd9955d7017ac2b529f44eb">getInterfaceForContainer</a> (juce::StringArray &amp;container)</td></tr>
<tr class="memdesc:a5451726fdfd9955d7017ac2b529f44eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html" title="Container interface that provides support for serializing juce::StringArrays with TreeReflector.">StringArrayInterface</a> for the given juce::StringArray.  <a href="namespacelemons_1_1serializing.html#a5451726fdfd9955d7017ac2b529f44eb">More...</a><br /></td></tr>
<tr class="separator:a5451726fdfd9955d7017ac2b529f44eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee820d761ae553c8ad6c5ce1a1ebe269"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , size_t size&gt; </td></tr>
<tr class="memitem:aee820d761ae553c8ad6c5ce1a1ebe269"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aee820d761ae553c8ad6c5ce1a1ebe269">getInterfaceForContainer</a> (std::array&lt; ElementType, size &gt; &amp;container)</td></tr>
<tr class="memdesc:aee820d761ae553c8ad6c5ce1a1ebe269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html" title="Container interface that provides support for serializing std::arrays with TreeReflector.">StdArrayInterface</a> for the given std::array.  <a href="namespacelemons_1_1serializing.html#aee820d761ae553c8ad6c5ce1a1ebe269">More...</a><br /></td></tr>
<tr class="separator:aee820d761ae553c8ad6c5ce1a1ebe269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f5a5656f4beb02e6db2e232c28ae67"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a07f5a5656f4beb02e6db2e232c28ae67"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a07f5a5656f4beb02e6db2e232c28ae67">getInterfaceForContainer</a> (std::deque&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a07f5a5656f4beb02e6db2e232c28ae67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::deque.  <a href="namespacelemons_1_1serializing.html#a07f5a5656f4beb02e6db2e232c28ae67">More...</a><br /></td></tr>
<tr class="separator:a07f5a5656f4beb02e6db2e232c28ae67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc3ef91761c11e3aa8f01e29e07f132"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:aebc3ef91761c11e3aa8f01e29e07f132"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#aebc3ef91761c11e3aa8f01e29e07f132">getInterfaceForContainer</a> (std::forward_list&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:aebc3ef91761c11e3aa8f01e29e07f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::forward_list.  <a href="namespacelemons_1_1serializing.html#aebc3ef91761c11e3aa8f01e29e07f132">More...</a><br /></td></tr>
<tr class="separator:aebc3ef91761c11e3aa8f01e29e07f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f40fa5baf10eca39436e00057d601b"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:a75f40fa5baf10eca39436e00057d601b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a75f40fa5baf10eca39436e00057d601b">getInterfaceForContainer</a> (std::list&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:a75f40fa5baf10eca39436e00057d601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::list.  <a href="namespacelemons_1_1serializing.html#a75f40fa5baf10eca39436e00057d601b">More...</a><br /></td></tr>
<tr class="separator:a75f40fa5baf10eca39436e00057d601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61433549df459186ab1bf2c3597d00c"><td class="memTemplParams" colspan="2">template&lt;typename ElementType &gt; </td></tr>
<tr class="memitem:ae61433549df459186ab1bf2c3597d00c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ae61433549df459186ab1bf2c3597d00c">getInterfaceForContainer</a> (std::vector&lt; ElementType &gt; &amp;container)</td></tr>
<tr class="memdesc:ae61433549df459186ab1bf2c3597d00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::vector.  <a href="namespacelemons_1_1serializing.html#ae61433549df459186ab1bf2c3597d00c">More...</a><br /></td></tr>
<tr class="separator:ae61433549df459186ab1bf2c3597d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a8faf0f6fcf3b46ecf735100cd0ec1ab9">toBinary</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data, File file)</td></tr>
<tr class="memdesc:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of an object to a file.  <a href="namespacelemons_1_1serializing.html#a8faf0f6fcf3b46ecf735100cd0ec1ab9">More...</a><br /></td></tr>
<tr class="separator:a8faf0f6fcf3b46ecf735100cd0ec1ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bc185517e15eeeaac3e5695a07993f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ac6bc185517e15eeeaac3e5695a07993f">toBinary</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data, juce::MemoryBlock &amp;dest)</td></tr>
<tr class="memdesc:ac6bc185517e15eeeaac3e5695a07993f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of an object to a juce::MemoryBlock.  <a href="namespacelemons_1_1serializing.html#ac6bc185517e15eeeaac3e5695a07993f">More...</a><br /></td></tr>
<tr class="separator:ac6bc185517e15eeeaac3e5695a07993f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56277361c7ff673091449ef6626be988"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988">toJSON</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:a56277361c7ff673091449ef6626be988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a JSON string.  <a href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988">More...</a><br /></td></tr>
<tr class="separator:a56277361c7ff673091449ef6626be988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#af9dd61f7eebbc83f0b49aeb0c9733327">toJSON</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source, const File &amp;file)</td></tr>
<tr class="memdesc:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a JSON file.  <a href="namespacelemons_1_1serializing.html#af9dd61f7eebbc83f0b49aeb0c9733327">More...</a><br /></td></tr>
<tr class="separator:af9dd61f7eebbc83f0b49aeb0c9733327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24582179ee786ad4ff22a82b3070d388"><td class="memItemLeft" align="right" valign="top">ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a24582179ee786ad4ff22a82b3070d388">toTree</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;data)</td></tr>
<tr class="memdesc:a24582179ee786ad4ff22a82b3070d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to a ValueTree.  <a href="namespacelemons_1_1serializing.html#a24582179ee786ad4ff22a82b3070d388">More...</a><br /></td></tr>
<tr class="separator:a24582179ee786ad4ff22a82b3070d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359990fb1af99d70295d10a13ddb2810"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a359990fb1af99d70295d10a13ddb2810"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a359990fb1af99d70295d10a13ddb2810">toVar</a> (juce::AudioBuffer&lt; double &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a359990fb1af99d70295d10a13ddb2810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an AudioBuffer to a var.  <a href="namespacelemons_1_1serializing.html#a359990fb1af99d70295d10a13ddb2810">More...</a><br /></td></tr>
<tr class="separator:a359990fb1af99d70295d10a13ddb2810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649c8f2bc41506fd655298cdf41de430"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a649c8f2bc41506fd655298cdf41de430"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a649c8f2bc41506fd655298cdf41de430">toVar</a> (juce::AudioBuffer&lt; float &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a649c8f2bc41506fd655298cdf41de430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an AudioBuffer to a var.  <a href="namespacelemons_1_1serializing.html#a649c8f2bc41506fd655298cdf41de430">More...</a><br /></td></tr>
<tr class="separator:a649c8f2bc41506fd655298cdf41de430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d788139f4116211d8426cf9bfd6aa7b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8d788139f4116211d8426cf9bfd6aa7b"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a8d788139f4116211d8426cf9bfd6aa7b">toVar</a> (juce::Image &amp;image)</td></tr>
<tr class="memdesc:a8d788139f4116211d8426cf9bfd6aa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Image object using the PNG image format.  <a href="namespacelemons_1_1serializing.html#a8d788139f4116211d8426cf9bfd6aa7b">More...</a><br /></td></tr>
<tr class="separator:a8d788139f4116211d8426cf9bfd6aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4002e6e67a670bb92651456865776534"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4002e6e67a670bb92651456865776534"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a4002e6e67a670bb92651456865776534">toVar</a> (juce::MemoryBlock &amp;block)</td></tr>
<tr class="memdesc:a4002e6e67a670bb92651456865776534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a MemoryBlock.  <a href="namespacelemons_1_1serializing.html#a4002e6e67a670bb92651456865776534">More...</a><br /></td></tr>
<tr class="separator:a4002e6e67a670bb92651456865776534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ecbed7b2fd709bf3a77251b6262ebd"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a54ecbed7b2fd709bf3a77251b6262ebd"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a54ecbed7b2fd709bf3a77251b6262ebd">toVar</a> (juce::MidiBuffer &amp;buffer)</td></tr>
<tr class="memdesc:a54ecbed7b2fd709bf3a77251b6262ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::MidiBuffer.  <a href="namespacelemons_1_1serializing.html#a54ecbed7b2fd709bf3a77251b6262ebd">More...</a><br /></td></tr>
<tr class="separator:a54ecbed7b2fd709bf3a77251b6262ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b32b87aef2397cb2c1930541106a9db"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5b32b87aef2397cb2c1930541106a9db"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a5b32b87aef2397cb2c1930541106a9db">toVar</a> (juce::Point&lt; float &gt; &amp;point)</td></tr>
<tr class="memdesc:a5b32b87aef2397cb2c1930541106a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a float Point.  <a href="namespacelemons_1_1serializing.html#a5b32b87aef2397cb2c1930541106a9db">More...</a><br /></td></tr>
<tr class="separator:a5b32b87aef2397cb2c1930541106a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10e604289c026559886af5c9bf1ff91"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae10e604289c026559886af5c9bf1ff91"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#ae10e604289c026559886af5c9bf1ff91">toVar</a> (juce::Point&lt; int &gt; &amp;point)</td></tr>
<tr class="memdesc:ae10e604289c026559886af5c9bf1ff91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an integer Point.  <a href="namespacelemons_1_1serializing.html#ae10e604289c026559886af5c9bf1ff91">More...</a><br /></td></tr>
<tr class="separator:ae10e604289c026559886af5c9bf1ff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a245e4f55875b6ac8fd9f2700ac791a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6a245e4f55875b6ac8fd9f2700ac791a"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a6a245e4f55875b6ac8fd9f2700ac791a">toVar</a> (juce::RelativeTime &amp;time)</td></tr>
<tr class="memdesc:a6a245e4f55875b6ac8fd9f2700ac791a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::RelativeTime object.  <a href="namespacelemons_1_1serializing.html#a6a245e4f55875b6ac8fd9f2700ac791a">More...</a><br /></td></tr>
<tr class="separator:a6a245e4f55875b6ac8fd9f2700ac791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a1e1d369f0916e2267cfb6e1f8171"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a335a1e1d369f0916e2267cfb6e1f8171"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a335a1e1d369f0916e2267cfb6e1f8171">toVar</a> (juce::Time &amp;time)</td></tr>
<tr class="memdesc:a335a1e1d369f0916e2267cfb6e1f8171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Time object by saving it as the number of milliseconds since the computing epoch.  <a href="namespacelemons_1_1serializing.html#a335a1e1d369f0916e2267cfb6e1f8171">More...</a><br /></td></tr>
<tr class="separator:a335a1e1d369f0916e2267cfb6e1f8171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77778b6f43a5a52acb50655157a79145"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77778b6f43a5a52acb50655157a79145"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a77778b6f43a5a52acb50655157a79145">toVar</a> (juce::URL &amp;url)</td></tr>
<tr class="memdesc:a77778b6f43a5a52acb50655157a79145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a URL as a String.  <a href="namespacelemons_1_1serializing.html#a77778b6f43a5a52acb50655157a79145">More...</a><br /></td></tr>
<tr class="separator:a77778b6f43a5a52acb50655157a79145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7ea751365cf15132fc3afa328dada"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abda7ea751365cf15132fc3afa328dada"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#abda7ea751365cf15132fc3afa328dada">toVar</a> (juce::Uuid &amp;uuid)</td></tr>
<tr class="memdesc:abda7ea751365cf15132fc3afa328dada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a juce::Uuid as a String.  <a href="namespacelemons_1_1serializing.html#abda7ea751365cf15132fc3afa328dada">More...</a><br /></td></tr>
<tr class="separator:abda7ea751365cf15132fc3afa328dada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae3657bad4740b539073b21e55d2212"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2ae3657bad4740b539073b21e55d2212"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a2ae3657bad4740b539073b21e55d2212">toVar</a> (std::string &amp;string)</td></tr>
<tr class="memdesc:a2ae3657bad4740b539073b21e55d2212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a std::string.  <a href="namespacelemons_1_1serializing.html#a2ae3657bad4740b539073b21e55d2212">More...</a><br /></td></tr>
<tr class="separator:a2ae3657bad4740b539073b21e55d2212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713bb9525856a131f6897cdd045d5bc4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a713bb9525856a131f6897cdd045d5bc4"><td class="memTemplItemLeft" align="right" valign="top">juce::var&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">toVar</a> (Type &amp;object)</td></tr>
<tr class="memdesc:a713bb9525856a131f6897cdd045d5bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>.  <a href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">More...</a><br /></td></tr>
<tr class="separator:a713bb9525856a131f6897cdd045d5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19051971222b714020a7e957034bcd1a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a19051971222b714020a7e957034bcd1a">toXML</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source)</td></tr>
<tr class="memdesc:a19051971222b714020a7e957034bcd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to an XML element.  <a href="namespacelemons_1_1serializing.html#a19051971222b714020a7e957034bcd1a">More...</a><br /></td></tr>
<tr class="separator:a19051971222b714020a7e957034bcd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe15521d50b5b08e071c2de702d7d3b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#afe15521d50b5b08e071c2de702d7d3b7">toXML</a> (<a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;source, const File &amp;file)</td></tr>
<tr class="memdesc:afe15521d50b5b08e071c2de702d7d3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an object to an XML file.  <a href="namespacelemons_1_1serializing.html#afe15521d50b5b08e071c2de702d7d3b7">More...</a><br /></td></tr>
<tr class="separator:afe15521d50b5b08e071c2de702d7d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="memItemLeft" align="right" valign="top">ValueTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0">valueTreeFromJSON</a> (const String &amp;jsonText)</td></tr>
<tr class="memdesc:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a JSON string to a ValueTree.  <a href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0">More...</a><br /></td></tr>
<tr class="separator:a3a28001c151ae9a72cee950b7b0c5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dc62981a244f674a7b47738595d0ac"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac">valueTreeToJSON</a> (const ValueTree &amp;v)</td></tr>
<tr class="memdesc:a44dc62981a244f674a7b47738595d0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ValueTree to a JSON string.  <a href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac">More...</a><br /></td></tr>
<tr class="separator:a44dc62981a244f674a7b47738595d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb42fe5922320e46884fd018dda44844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb42fe5922320e46884fd018dda44844">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from one serializable object to another by serializing the source object to a ValueTree, then deserializing the dest object from that tree. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#aa047dfa3783a67d4d6690647dd45b43b">createCopy()</a>.</p>

</div>
</div>
<a id="aa047dfa3783a67d4d6690647dd45b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047dfa3783a67d4d6690647dd45b43b">&#9670;&nbsp;</a></span>createCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::createCopy </td>
          <td>(</td>
          <td class="paramtype">ObjectType &amp;&#160;</td>
          <td class="paramname"><em>objectToCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of a serializable object by deserializing from the state of the source object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#afb42fe5922320e46884fd018dda44844">copy()</a>.</p>

</div>
</div>
<a id="acad0f4cabd407e51b0a9f3d57512a3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad0f4cabd407e51b0a9f3d57512a3be">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a juce::MemoryBlock. </p>

</div>
</div>
<a id="a9ffdb3b15a1380f98483a7b6bb3066bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffdb3b15a1380f98483a7b6bb3066bd">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from some arbitrary opaque binary data. </p>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a84997a7ac9a18b678f39168ba81eafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84997a7ac9a18b678f39168ba81eafdc">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from some arbitrary opaque binary data. </p>

</div>
</div>
<a id="a47707d97df8e371fd661c3cf03ed1490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47707d97df8e371fd661c3cf03ed1490">&#9670;&nbsp;</a></span>fromBinary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromBinary </td>
          <td>(</td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a file. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a9ffdb3b15a1380f98483a7b6bb3066bd">fromBinary()</a>, and <a class="el" href="namespacelemons_1_1serializing.html#a2487acb4af683b23c36066e5d8caca34">fromBinaryCreate()</a>.</p>

</div>
</div>
<a id="a0004a5eeed7ab3e5e3826c74e094025e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0004a5eeed7ab3e5e3826c74e094025e">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the MemoryBlock. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2c211f61be5553bd45adc7db3b82b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c211f61be5553bd45adc7db3b82b159">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , typename IntegerType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the opaque binary data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a354e5c3379aab3b3d5daa98339bd2376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354e5c3379aab3b3d5daa98339bd2376">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the opaque binary data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2487acb4af683b23c36066e5d8caca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2487acb4af683b23c36066e5d8caca34">&#9670;&nbsp;</a></span>fromBinaryCreate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromBinaryCreate </td>
          <td>(</td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a47707d97df8e371fd661c3cf03ed1490">fromBinary()</a>.</p>

</div>
</div>
<a id="a2913994bf9e1138ac4f7b70ddaa7b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2913994bf9e1138ac4f7b70ddaa7b632">&#9670;&nbsp;</a></span>fromJSON() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromJSON </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a JSON file. </p>

</div>
</div>
<a id="ac4200231299743257683b69fbd3303e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4200231299743257683b69fbd3303e8">&#9670;&nbsp;</a></span>fromJSON() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromJSON </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a JSON string. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a353856dc5625616d6d75fb7ab7b2845b">fromJSONCreate()</a>.</p>

</div>
</div>
<a id="adbc84bfe67d82766e8ed1db9c40b6ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc84bfe67d82766e8ed1db9c40b6ad2">&#9670;&nbsp;</a></span>fromJSONCreate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromJSONCreate </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the JSON file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a44dc62981a244f674a7b47738595d0ac" title="Converts a ValueTree to a JSON string.">valueTreeToJSON()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON()</a>.</p>

</div>
</div>
<a id="a353856dc5625616d6d75fb7ab7b2845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353856dc5625616d6d75fb7ab7b2845b">&#9670;&nbsp;</a></span>fromJSONCreate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromJSONCreate </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the JSON string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a3a28001c151ae9a72cee950b7b0c5fe0" title="Converts a JSON string to a ValueTree.">valueTreeFromJSON()</a> </dd></dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#ac4200231299743257683b69fbd3303e8">fromJSON()</a>.</p>

</div>
</div>
<a id="a7eb10991a286ec6cedc990a98a587def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb10991a286ec6cedc990a98a587def">&#9670;&nbsp;</a></span>fromTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromTree </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from a ValueTree. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a449fb4b02e490125b488a21ea568d0cb">fromTreeCreate()</a>.</p>

</div>
</div>
<a id="a449fb4b02e490125b488a21ea568d0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449fb4b02e490125b488a21ea568d0cb">&#9670;&nbsp;</a></span>fromTreeCreate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromTreeCreate </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the ValueTree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#a7eb10991a286ec6cedc990a98a587def">fromTree()</a>.</p>

</div>
</div>
<a id="aeff235d9553fa3ebf08d80086b25c41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff235d9553fa3ebf08d80086b25c41e">&#9670;&nbsp;</a></span>fromVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::MidiBuffer lemons::serializing::fromVar </td>
          <td>(</td>
          <td class="paramtype">juce::var&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an AudioBuffer from a var. </p>
<p>Serializes a juce::MidiBuffer.</p>
<p>Serializes a juce::Image object using the PNG image format.</p>
<p>Serializes a juce::RelativeTime object.</p>
<p>Serializes a juce::Time object by loading it as the number of milliseconds since the computing epoch.</p>
<p>Serializes a juce::Uuid as a String.</p>
<p>Serializes a std::string.</p>
<p>Serializes a URL as a String.</p>
<p>Serializes a MemoryBlock.</p>
<p>Serializes an integer Point.</p>
<p>Serializes a float Point.</p>
<p>Explicitly calls juce::var::toString().</p>
<p>Internally, this converts the var to a String, then uses juce's FlacAudioFormat to decode the String back into audio samples.</p>
<p>Internally, this converts the var to a String, then uses juce's FlacAudioFormat to decode the String back into audio samples. <br  />
Since juce's FlacAudioFormat is only available for float samples, the buffer is first decoded with float samples and then converted to double samples for the final result.</p>
<p>This works by reading the contents of a String into binary form, using Base64 encoding.</p>
<p>Deserializes an AudioBuffer from a var.</p>
<p>This function must load the complete state of your object from a juce::var. Your object type must be default-constructable. <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is creating a default-constructed instance of your object, then setting properties or relevant data members programmatically based on parsing the encoded String returned from the var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="abd30f255b2b10402a940e2260f7ede3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd30f255b2b10402a940e2260f7ede3b">&#9670;&nbsp;</a></span>fromVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type lemons::serializing::fromVar </td>
          <td>(</td>
          <td class="paramtype">juce::var&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>. </p>
<p>Deserializes an AudioBuffer from a var.</p>
<p>This function must load the complete state of your object from a juce::var. Your object type must be default-constructable. <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is creating a default-constructed instance of your object, then setting properties or relevant data members programmatically based on parsing the encoded String returned from the var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="a6351ecfc79867a4cf7a66df393babd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6351ecfc79867a4cf7a66df393babd61">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>xmlFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML file. </p>

</div>
</div>
<a id="abfacae1d4cf28387b0b128aa39addc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfacae1d4cf28387b0b128aa39addc51">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">const juce::XmlElement &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML element. </p>

<p class="reference">Referenced by <a class="el" href="namespacelemons_1_1serializing.html#a4632b6fdd6053f46aea6ca54e5601481">fromXMLCreate()</a>.</p>

</div>
</div>
<a id="aead8fccdf0fa475eee8d5277a1c7267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead8fccdf0fa475eee8d5277a1c7267d">&#9670;&nbsp;</a></span>fromXML() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::fromXML </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes an object from an XML element. </p>

</div>
</div>
<a id="abe32c3104102c45dfde9bc5cd313b5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe32c3104102c45dfde9bc5cd313b5de">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>xmlFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a4632b6fdd6053f46aea6ca54e5601481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4632b6fdd6053f46aea6ca54e5601481">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">const juce::XmlElement &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a48182b6e883c283d2cdf15bd1bd360ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48182b6e883c283d2cdf15bd1bd360ec">&#9670;&nbsp;</a></span>fromXMLCreate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , BV_MUST_INHERIT_FROM(ObjectType, SerializableData) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType lemons::serializing::fromXMLCreate </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; juce::XmlElement &gt;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object from the state saved in the XML element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>The type of object to create. This type must inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a> and must be default-constructable. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacelemons_1_1serializing.html#abfacae1d4cf28387b0b128aa39addc51">fromXML()</a>.</p>

</div>
</div>
<a id="a947d1fd48af7f4413f461f6c741d5fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947d1fd48af7f4413f461f6c741d5fc2">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function that returns an instance of the correct <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a> for the given container. </p>
<p>Implement this if you want to be able to serialize a custom container type with a single <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a> call. <br  />
<br  />
</p><div class="fragment"><div class="line">    To add support <span class="keywordflow">for</span> a custom container type to <a class="code" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883">TreeReflector::add</a>():</div>
<div class="line">    - Implement a subclass of serializing::ContainerInterface with the correct resizing logic for your cotainer;</div>
<div class="line">    - Implement a specialization ofserializing::getContainerForInterface() that returns an instance of your custom interface;</div>
<div class="line">    - Specialize the serializing::isContainer struct for your type and make the specialization inherit from std::true_type.</div>
<div class="line"> </div>
<div class="line">    In addition, your custom container type must have begin() and end() functions -- ie, it must be compatable with range-based for loops.</div>
<div class="line">    </div>
<div class="line">    The elements of your container must also be valid TreeReflector::add() calls -- ie, if they don&#39;t inherit SerializableData, you must implement <a class="code" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">toVar</a>() and <a class="code" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">fromVar</a>() for the container&#39;s element type as well.</div>
<div class="line"> </div>
<div class="line">    Here is an example implementation for a custom type:</div>
<div class="line"> </div>
<div class="line">    template&lt;typename ElementType&gt;</div>
<div class="line">    struct MyContainerType</div>
<div class="line">    {</div>
<div class="line">        ElementType* begin();</div>
<div class="line">        ElementType* end();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> setSize (<span class="keywordtype">int</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: implement container interface</span></div>
<div class="line">    <span class="comment">// This tells the TreeReflector how to resize your container</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElementType&gt;</div>
<div class="line">    <span class="keyword">struct </span>MyContainerInterface : <a class="code" href="structlemons_1_1serializing_1_1ContainerInterface.html">lemons::serializing::ContainerInterface</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> Container = MyContainerType&lt;ElementType&gt;;</div>
<div class="line"> </div>
<div class="line">        MyContainerInterface (Container&amp; c) : container (c) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">void</span> resize (<span class="keywordtype">int</span> newSize) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        container.setSize (newSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        Container&amp; container;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: implement getInterfaceForContainer()</span></div>
<div class="line">    <span class="comment">// This creates an instance of your container interface for the TreeReflector to use</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ElementType &gt;</div>
<div class="line">    std::unique_ptr&lt; ContainerInterface &gt; <a class="code" href="namespacelemons_1_1serializing.html#a947d1fd48af7f4413f461f6c741d5fc2">getInterfaceForContainer</a> (MyContainerType&lt; ElementType &gt;&amp; container)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt; MyContainerInterface&lt; ElementType &gt; &gt; (container);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: implement isContainer</span></div>
<div class="line">    <span class="comment">// This tells TreeReflector that any specialization of your container type is a kind of container</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ElementType &gt;</div>
<div class="line">    <span class="keyword">struct </span>isContainer&lt; MyContainerType&lt; ElementType &gt; &gt; : std::true_type</div>
<div class="line">    {</div>
<div class="line">    };</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>The fully specialized container type &ndash; for example, std::vector&lt;int&gt; or juce::Array&lt;float&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a>, <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html" title="Interface that defines how a TreeReflector can resize a given container during deserialization.">ContainerInterface</a>, <a class="el" href="structlemons_1_1serializing_1_1isContainer.html" title="Template struct that that indicates to TreeReflector whether a given type is a container.">isContainer</a> </dd></dl>

</div>
</div>
<a id="acaa9bcf94a6a18b321714a7425ff0a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa9bcf94a6a18b321714a7425ff0a83">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::Array&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceArrayInterface.html" title="Container interface that provides support for serializing juce::Arrays with TreeReflector.">JuceArrayInterface</a> for the given juce::Array. </p>

</div>
</div>
<a id="a62bdd53db8c515549f20b1f0835052b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bdd53db8c515549f20b1f0835052b7">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::OwnedArray&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1JuceOwnedArrayInterface.html" title="Container interface that provides support for serializing juce::OwnedArrays with TreeReflector.">JuceOwnedArrayInterface</a> for the given juce::OwnedArray. </p>

</div>
</div>
<a id="a5451726fdfd9955d7017ac2b529f44eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5451726fdfd9955d7017ac2b529f44eb">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">juce::StringArray &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StringArrayInterface.html" title="Container interface that provides support for serializing juce::StringArrays with TreeReflector.">StringArrayInterface</a> for the given juce::StringArray. </p>

</div>
</div>
<a id="aee820d761ae553c8ad6c5ce1a1ebe269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee820d761ae553c8ad6c5ce1a1ebe269">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; ElementType, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1StdArrayInterface.html" title="Container interface that provides support for serializing std::arrays with TreeReflector.">StdArrayInterface</a> for the given std::array. </p>

</div>
</div>
<a id="a07f5a5656f4beb02e6db2e232c28ae67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f5a5656f4beb02e6db2e232c28ae67">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::deque. </p>

</div>
</div>
<a id="aebc3ef91761c11e3aa8f01e29e07f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc3ef91761c11e3aa8f01e29e07f132">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::forward_list&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::forward_list. </p>

</div>
</div>
<a id="a75f40fa5baf10eca39436e00057d601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f40fa5baf10eca39436e00057d601b">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::list. </p>

</div>
</div>
<a id="ae61433549df459186ab1bf2c3597d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61433549df459186ab1bf2c3597d00c">&#9670;&nbsp;</a></span>getInterfaceForContainer() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structlemons_1_1serializing_1_1ContainerInterface.html">ContainerInterface</a> &gt; lemons::serializing::getInterfaceForContainer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ElementType &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of <a class="el" href="structlemons_1_1serializing_1_1STLContainerInterface.html" title="Container interface that provides support for serializing most STL containers with TreeReflector.">STLContainerInterface</a> for the given std::vector. </p>

</div>
</div>
<a id="a8faf0f6fcf3b46ecf735100cd0ec1ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf0f6fcf3b46ecf735100cd0ec1ab9">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">File&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of an object to a file. </p>
<p>Internally, this method calls juce::ValueTree::writeToStream(), so the data is stored as an arbitrary binary encoding of a ValueTree, not necessarily a common format like XML or JSON. <br  />
 <br  />
Use the XML- and JSON-specific functions in this namespace to explicitly use either format. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#a19051971222b714020a7e957034bcd1a" title="Serializes an object to an XML element.">toXML()</a>, <a class="el" href="namespacelemons_1_1serializing.html#a56277361c7ff673091449ef6626be988" title="Serializes an object to a JSON string.">toJSON()</a> </dd></dl>

</div>
</div>
<a id="ac6bc185517e15eeeaac3e5695a07993f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bc185517e15eeeaac3e5695a07993f">&#9670;&nbsp;</a></span>toBinary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of an object to a juce::MemoryBlock. </p>

</div>
</div>
<a id="a56277361c7ff673091449ef6626be988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56277361c7ff673091449ef6626be988">&#9670;&nbsp;</a></span>toJSON() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String lemons::serializing::toJSON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a JSON string. </p>

</div>
</div>
<a id="af9dd61f7eebbc83f0b49aeb0c9733327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dd61f7eebbc83f0b49aeb0c9733327">&#9670;&nbsp;</a></span>toJSON() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toJSON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a JSON file. </p>

</div>
</div>
<a id="a24582179ee786ad4ff22a82b3070d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24582179ee786ad4ff22a82b3070d388">&#9670;&nbsp;</a></span>toTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree lemons::serializing::toTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to a ValueTree. </p>

</div>
</div>
<a id="a359990fb1af99d70295d10a13ddb2810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359990fb1af99d70295d10a13ddb2810">&#9670;&nbsp;</a></span>toVar() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::AudioBuffer&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an AudioBuffer to a var. </p>
<p>Since juce's FlacAudioFormat is only available for float samples, this first converts the buffer to floats and then uses juce::FlacAudioFormat to write the buffer's contents to a String. </p>

</div>
</div>
<a id="a649c8f2bc41506fd655298cdf41de430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649c8f2bc41506fd655298cdf41de430">&#9670;&nbsp;</a></span>toVar() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::AudioBuffer&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an AudioBuffer to a var. </p>
<p>Internally, this uses juce's FlacAudioFormat to write the buffer's contents into a String. </p>

</div>
</div>
<a id="a8d788139f4116211d8426cf9bfd6aa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d788139f4116211d8426cf9bfd6aa7b">&#9670;&nbsp;</a></span>toVar() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Image object using the PNG image format. </p>

</div>
</div>
<a id="a4002e6e67a670bb92651456865776534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002e6e67a670bb92651456865776534">&#9670;&nbsp;</a></span>toVar() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::MemoryBlock &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a MemoryBlock. </p>
<p>This works by writing the contents of the memory block to a String use Base64 encoding. </p>

</div>
</div>
<a id="a54ecbed7b2fd709bf3a77251b6262ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ecbed7b2fd709bf3a77251b6262ebd">&#9670;&nbsp;</a></span>toVar() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::MidiBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::MidiBuffer. </p>

</div>
</div>
<a id="a5b32b87aef2397cb2c1930541106a9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b32b87aef2397cb2c1930541106a9db">&#9670;&nbsp;</a></span>toVar() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::Point&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a float Point. </p>

</div>
</div>
<a id="ae10e604289c026559886af5c9bf1ff91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10e604289c026559886af5c9bf1ff91">&#9670;&nbsp;</a></span>toVar() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::Point&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an integer Point. </p>

</div>
</div>
<a id="a6a245e4f55875b6ac8fd9f2700ac791a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a245e4f55875b6ac8fd9f2700ac791a">&#9670;&nbsp;</a></span>toVar() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::RelativeTime &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::RelativeTime object. </p>

</div>
</div>
<a id="a335a1e1d369f0916e2267cfb6e1f8171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335a1e1d369f0916e2267cfb6e1f8171">&#9670;&nbsp;</a></span>toVar() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Time object by saving it as the number of milliseconds since the computing epoch. </p>

</div>
</div>
<a id="a77778b6f43a5a52acb50655157a79145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77778b6f43a5a52acb50655157a79145">&#9670;&nbsp;</a></span>toVar() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::URL &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a URL as a String. </p>

</div>
</div>
<a id="abda7ea751365cf15132fc3afa328dada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7ea751365cf15132fc3afa328dada">&#9670;&nbsp;</a></span>toVar() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">juce::Uuid &amp;&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a juce::Uuid as a String. </p>

</div>
</div>
<a id="a2ae3657bad4740b539073b21e55d2212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae3657bad4740b539073b21e55d2212">&#9670;&nbsp;</a></span>toVar() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a std::string. </p>

</div>
</div>
<a id="a713bb9525856a131f6897cdd045d5bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713bb9525856a131f6897cdd045d5bc4">&#9670;&nbsp;</a></span>toVar() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">juce::var lemons::serializing::toVar </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement this function and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for any custom type to allow easily serialization using <a class="el" href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883" title="Binds a named ValueTree property to a data member of your object.">TreeReflector::add()</a>. </p>
<p>This function must save the complete state of your object either directly to a juce::var or to a type that is implicitly convertable to juce::var (ie, float, int, juce::String, etc.). <br  />
 <br  />
This function must do the exact opposite of what your implementation of <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for your type does. <br  />
 <br  />
Usually what this boils down to is encoding your object into a juce::String in some way, which can then be implicitly converted to a juce::var. <br  />
 <br  />
Several examples of implementations of this function can be found in lemons_serializing/Serializing/Specializations/VarSpecializations.cpp. <br  />
 <br  />
As a general rule, you shouldn't need to implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if that type inherits from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>; and, conversely, you should implement <a class="el" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4" title="Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...">toVar()</a> and <a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a> for a type if it needs to be serialized and doesn't inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. You should rarely, if ever, need both for a single type. If your type has multiple distinct pieces of data or steps to its serialization logic, it is usually preferable to have your type inherit from <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>. </p><div class="fragment"><div class="line"><span class="comment">// example implementation:</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacelemons.html">lemons</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    juce::var <a class="code" href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">toVar</a> (MyCustomType&amp; <span class="keywordtype">object</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    MyCustomType <a class="code" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">fromVar</a> (juce::var var)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// implement your conversion logic here...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// example usage:</span></div>
<div class="line"><span class="keyword">struct </span>SomethingSerializable : <a class="code" href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> serialize (TreeReflector&amp; ref) <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TreeReflector will internally call toVar to save your object and fromVar to load your object</span></div>
<div class="line">        ref.add (<span class="stringliteral">&quot;MyCustomData&quot;</span>, data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyCustomType data;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b" title="Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...">fromVar()</a>, <a class="el" href="structlemons_1_1SerializableData.html" title="Base class for any C++ object that needs to be serialized to binary and back.">SerializableData</a>, <a class="el" href="structlemons_1_1TreeReflector.html" title="Utility class that provides a convenient API for assigning data members or lambdas to ValueTree prope...">TreeReflector</a> </dd></dl>

</div>
</div>
<a id="a19051971222b714020a7e957034bcd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19051971222b714020a7e957034bcd1a">&#9670;&nbsp;</a></span>toXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; juce::XmlElement &gt; lemons::serializing::toXML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to an XML element. </p>

</div>
</div>
<a id="afe15521d50b5b08e071c2de702d7d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe15521d50b5b08e071c2de702d7d3b7">&#9670;&nbsp;</a></span>toXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lemons::serializing::toXML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlemons_1_1SerializableData.html">SerializableData</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const File &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an object to an XML file. </p>

</div>
</div>
<a id="a3a28001c151ae9a72cee950b7b0c5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a28001c151ae9a72cee950b7b0c5fe0">&#9670;&nbsp;</a></span>valueTreeFromJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree lemons::serializing::valueTreeFromJSON </td>
          <td>(</td>
          <td class="paramtype">const String &amp;&#160;</td>
          <td class="paramname"><em>jsonText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a JSON string to a ValueTree. </p>

</div>
</div>
<a id="a44dc62981a244f674a7b47738595d0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dc62981a244f674a7b47738595d0ac">&#9670;&nbsp;</a></span>valueTreeToJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String lemons::serializing::valueTreeToJSON </td>
          <td>(</td>
          <td class="paramtype">const ValueTree &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ValueTree to a JSON string. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacelemons_1_1serializing_html_a713bb9525856a131f6897cdd045d5bc4"><div class="ttname"><a href="namespacelemons_1_1serializing.html#a713bb9525856a131f6897cdd045d5bc4">lemons::serializing::toVar</a></div><div class="ttdeci">juce::var toVar(Type &amp;object)</div><div class="ttdoc">Implement this function and fromVar() for any custom type to allow easily serialization using TreeRef...</div><div class="ttdef"><b>Definition:</b> VarConversion.h:46</div></div>
<div class="ttc" id="astructlemons_1_1SerializableData_html"><div class="ttname"><a href="structlemons_1_1SerializableData.html">lemons::SerializableData</a></div><div class="ttdoc">Base class for any C++ object that needs to be serialized to binary and back.</div><div class="ttdef"><b>Definition:</b> SerializableData.h:12</div></div>
<div class="ttc" id="astructlemons_1_1serializing_1_1ContainerInterface_html"><div class="ttname"><a href="structlemons_1_1serializing_1_1ContainerInterface.html">lemons::serializing::ContainerInterface</a></div><div class="ttdoc">Interface that defines how a TreeReflector can resize a given container during deserialization.</div><div class="ttdef"><b>Definition:</b> ContainerInterface.h:13</div></div>
<div class="ttc" id="astructlemons_1_1TreeReflector_html_aa0c4f2b619acd9a3287a1f27d4c23883"><div class="ttname"><a href="structlemons_1_1TreeReflector.html#aa0c4f2b619acd9a3287a1f27d4c23883">lemons::TreeReflector::add</a></div><div class="ttdeci">void add(const String &amp;propertyName, Type &amp;object)</div><div class="ttdoc">Binds a named ValueTree property to a data member of your object.</div><div class="ttdef"><b>Definition:</b> Common/lemons_serializing/SerializableData/TreeReflector/detail.h:9</div></div>
<div class="ttc" id="anamespacelemons_html"><div class="ttname"><a href="namespacelemons.html">lemons</a></div><div class="ttdef"><b>Definition:</b> DefaultWindow.h:6</div></div>
<div class="ttc" id="anamespacelemons_1_1serializing_html_a947d1fd48af7f4413f461f6c741d5fc2"><div class="ttname"><a href="namespacelemons_1_1serializing.html#a947d1fd48af7f4413f461f6c741d5fc2">lemons::serializing::getInterfaceForContainer</a></div><div class="ttdeci">std::unique_ptr&lt; ContainerInterface &gt; getInterfaceForContainer(ContainerType &amp;)</div><div class="ttdoc">Template function that returns an instance of the correct ContainerInterface for the given container.</div></div>
<div class="ttc" id="anamespacelemons_1_1serializing_html_abd30f255b2b10402a940e2260f7ede3b"><div class="ttname"><a href="namespacelemons_1_1serializing.html#abd30f255b2b10402a940e2260f7ede3b">lemons::serializing::fromVar</a></div><div class="ttdeci">Type fromVar(juce::var var)</div><div class="ttdoc">Implement this function and toVar() for any custom type to allow easily serialization using TreeRefle...</div><div class="ttdef"><b>Definition:</b> VarConversion.h:92</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 4 2021 05:08:05 for Lemons by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
